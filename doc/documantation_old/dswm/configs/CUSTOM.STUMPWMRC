;; CUSTOM.STUMPWMRC --- my own Stumpwm customizations
;; Copyright (C) 2008 by S.P.Tseng
;; Author: S.P.Tseng <deftsp@gmail.com>
;; License: public domain
;; When: Time-stamp: "2008-07-28 11:10:10 S.P.Tseng"
;; Keywords: local,customization,Stumpwm
;; Commentary: Modifies visual appearance of mode-line, input box, X windows; adds numerous key bindings
;; and heavily integrates Surfraw shortcuts. Includes some helper/utility functions.

;;-----------------------------------------------------------------------------------------------------------------------
;;; Global variables
;;-----------------------------------------------------------------------------------------------------------------------
;;; Declare our default programs for certain things, and how visually things will look.

;; Declare what this file is for.
(in-package :dswm)

;;; Variables
;; suppress the message StumpWM displays when it starts. Set it to NIL
(setf *startup-message* nil)
(setf *startup-message* "Never Stop Hacking!")
;;Run-or-raise work through multiple screens
;; (setf *run-or-raise-all-screens* 't)
;;; mouse
;; The mouse focus policy decides how the mouse affects input focus
(setf *mouse-focus-policy* :click)

;;; Window Appearance
;; The width in pixels given to the borders of regular windows.
(setf *normal-border-width* 0)
;; The width in pixels given to the borders of windows with maxsize or ratio hints.
(setf *maxsize-border-width* 0)
;; The width in pixels given to the borders of transient or pop-up windows.
(setf *transient-border-width* 1)

(defparameter FOREGROUND-COLOR "green")
(defparameter BACKGROUND-COLOR "black")
(defparameter BORDER-COLOR "green")

;; Window border colors.
(set-focus-color BACKGROUND-COLOR)
(set-unfocus-color BACKGROUND-COLOR)
(set-win-bg-color BACKGROUND-COLOR)

(setf *window-border-style* :thick) ; :thick :thin :tight :none

;; Input box colors
(set-bg-color BACKGROUND-COLOR)
(set-fg-color "forestgreen")
(set-border-color "SteelBlue")
(set-msg-border-width 0)
(setf *input-window-gravity* :bottom-right)

;; Set the message and input box to the bottom right. This way it overlaps with mode-line.
(setf *message-window-gravity* :bottom-right)
;; in seconds, how long a message will appear for. This must be an integer.
(setf *timeout-wait* 5)

;;; frame
(set-frame-outline-width 1)
;; (setf *new-window-preferred-frame* '(:empty :focused))
;; I just don't like zero indexing frames/windows. 0 is not next to 1
;; on the keyboard! See ;; <http://lists.gnu.org/archive/html/dswm-devel/2006-08/msg00002.html>
;; (setf *frame-number-map* "1234567890")
(setf *frame-number-map* "jkluio789")

;;Dswm crashes or freezes too much. If we set the debug up to ludicoursly high levels, maybe we'll learn something.
(setf dswm::*debug-level* 10)



;; Additional keysyms
;; (define-keysym #x1008ff31 "XF86AudioPause")
;; (define-keysym #x1008ff15 "XF86AudioStop")
;; (define-keysym #x1008ff17 "XF86AudioNext")
;; (define-keysym #x1008ff16 "XF86AudioPrev")
;; (define-keysym #x1008ff87 "XF86Video")

;;----------------------------------------------------------------------------------------------------
;;; Functions, aliases, macros
;;----------------------------------------------------------------------------------------------------
;; Useful things. Usually defining new Dswm commands.

;; I don't really want to be constantly typing "concatenate 'string" - this simplifies things. Thanks to sabetts of
;; #dswm
(defun cat (&rest strings)
"Concatenates strings, like the Unix command 'cat'. A shortcut for (concatenate 'string foo bar)."
(apply 'concatenate 'string strings))


;;; find window and to what your whant.
(defun find-window-group/dss (group props)
(find-if (lambda (w)
(apply 'window-matches-properties-p w props))
(group-windows group)))

(defun find-window-range (props &optional all-groups all-screens)
(let ((screens (if all-screens
*screen-list*
(list (current-screen)))))
(if all-groups
(loop named outer
for s in screens
do (loop
for g in (screen-groups s)
for win = (find-window-group g props)
when win
do (return-from outer win)))
(find-window-group (current-group) props))))


(defun to-window (win)
(let* ((group (window-group win))
(frame (window-frame win))
(old-frame (tile-group-current-frame group)))
(frame-raise-window group frame win)
(focus-all win)
(unless (eq frame old-frame)
(show-frame-indicator group))))

(defun find-window-dwim (props &key all-groups all-screens do-func send-str exec-shell switch-to to-and-back)
(let ((win (find-window-range props all-groups all-screens))
(last-window (if to-and-back
(current-window))))
(if win
(if (or switch-to to-and-back)
(progn
(to-window win)
do-func
(if exec-shell (if (run-shell-command exec-shell t)
(if to-and-back (to-window last-window)))))
(progn
(eval do-func)
(if send-str (window-send-string win send-str))
(if exec-shell (run-shell-command exec-shell))))
(message "No such windows!"))))
(export 'find-window-dwim)

;; macro for faster startups
(defmacro replace-hook (hook fn)
`(remove-hook, hook, fn)
`(add-hook, hook, fn))

;; todo: use function user-homedir-pathname and merge-pathnames to update it.
(defun expand-file-name (path &optional default-directory)
(let ((first-char (subseq path 0 1))
(home-dir (cat (getenv "HOME") "/"))
(dir (if default-directory
(if (string= (subseq (reverse default-directory) 0 1) "/")
default-directory
(cat default-directory "/")))))
(cond ((string= first-char "~") (cat home-dir (subseq path 2)))
((string= first-char "/") path)
(dir (if (string= (subseq dir 0 1) "/")
(cat dir path)
(expand-file-name (cat dir path))))
(t (cat home-dir path)))))

(defun shell-command (command)
"Run a shell command and display output to screen.
This must be used in a functional side-effects-free style! If a program does not
exit of its own accord, Dswm might hang!"
(check-type command string)
(echo-string (current-screen) (dswm::run-shell-command command t)))

;; (defcommand "my-shell-command" ((command :string "sh: " :string))
;; (check-type command string)
;; (shell-command command))

(defcommand my-shell-command (command) ((:string "sh$ "))
(check-type command string)
(shell-command command))

;; (defun load-contrib (file)
;; "Load a file in the contrib directory"
;; (let ((truename (concatenate 'string *contrib-dir* "contrib/" file)))
;; (format t "Loading contribution file: ~A~%" truename)
;; (when (probe-file truename)
;; (load truename))))


;;; Font
;; (set-font "-artwiz-snap-normal-*-*-*-*-*-*-*-*-*-iso10646-*")
;; (set-font "-*-wenquanyi bitmap song-medium-r-normal-*-13-*-*-*-*-*-iso10646-*")
;; (set-font "-xos4-*-medium-r-normal-*-12-*-*-*-*-*-*-*")
(set-font "-*-profont-medium-r-normal-*-14-*-*-*-*-*-iso8859-*")
;; (set-font "-*-comic sans ms-medium-r-normal-*-12-*-*-*-*-*-*-*")
;; Set the 1337 lisp machine font
;; (set-font "-lispm-fixed-medium-r-normal-*-13-*-*-*-*-*-*-*")

(defparameter X-TERM "exec urxvt"
"What shall be the command run when we want an X terminal?")

;; Text browsers are good, too.
(defparameter X-TERM-BROWSER (cat X-TERM " -e w3m")
"We will want to open up our chosen CLI web browser in our chosen X terminal. What is it?")

;; Yay for GUI web browsing!
(defparameter X-WWW-BROWSER "exec firefox "
"What GUI WWW browser shall we use?")

;; Image viewers can be useful.
(defparameter X-IMAGE-VIEWER "exec gqview "
"Sometimes I like to look at images. We need some sort of client for that.")

;; Set the default shell
;; (setf *shell-program* (dswm::getenv "SHELL")) ;getenv is not exported


;;; Controlling Raise And Map Request

;; (unless dswm:*deny-map-request*
;; ;; Deny transient raise requests
;; (push '(:transient) dswm:*deny-map-request*)
;; (push '(:class "Firefox-bin") dswm:*deny-map-request*)
;; (push '(:class "Stardict") dswm:*deny-map-request*)
;; (push '(:title "Download Manager") *deny-map-request*)
;; (push '(:title "Downloads") *deny-map-request*)
;; (push '(:title "JabRef") *deny-map-request*)
;; (push '(:title "Download Manager") *deny-raise-request*)
;; (push '(:title "Downloads") *deny-raise-request*)
;; (push '(:title "JabRef") *deny-raise-request*)
;; (push '(:class "Emacs") dswm:*deny-map-request*))

(setf *suppress-deny-messages* t)
;; (setf *format-time-string-default* "%a %b %e %k: %M")

;;; notifications
(load (expand-file-name "~/src/dswm/contrib/notifications.lisp"))

(define-key *root-map* (kbd "N") '*notifications-map*)

;; (defun notify (fmt args)
;; (let ((*executing-dswm-command* nil)
;; (*message-window-gravity* :center))
;; (message-no-timeout fmt args)))
;;(export 'notify)

;; (define-dswm-command "notify" ((msg :rest "Notify: "))
;; (notify "~a" msg))


;;; Modeline
(setf *mode-line-background-color* BACKGROUND-COLOR
*mode-line-border-color* BORDER-COLOR
*mode-line-foreground-color* "forestgreen"
*mode-line-border-width* 0 ; "How thick shall the mode line border be?"
;; "How much padding should be between the mode line text and the sides?"
*mode-line-pad-x* 0
*mode-line-pad-y* 0
*mode-line-position* :top ; bottom
*mode-line-timeout* 10) ; Update every 10 seconds if nothing else has triggered it already.

;; (setf *group-format* "%s%t")

(defun fix-str-length (str length)
(if (> (length str) length)
(cat (subseq str 0 (- length 2)) ".*")
(format nil "~va" length str)))

(defun fmt-window-list (ml)
"Using *window-format*, return a 1 line list of the windows, space seperated."
(fix-str-length (format nil "~{~a~^ ~}"
(mapcar (lambda (w) (format-expand *window-formatters* *window-format* w))
(sort-windows (mode-line-current-group ml)))) 47))

(setf *window-name-source* :title)
(setf *window-format* "%m%n%s%50c")

(defun check-mail (path)
(labels ((mail-number-color (nmail)
(if (= nmail 0) "" "^B^6*")))
(let ((nmail (length (directory (concatenate 'string path "*")))))
(format nil "Mail: ^[~A~2D^] " (mail-number-color nmail) nmail))))

;; (defun check-mail ()
;; (let ((nmail (run-shell-command "ls /home/tsp/Mail/inbox/new/ |wc -l | tr -d [:cntrl:][:space:]" t)))
;; (format nil "Mail: ~2a " nmail)))

(defun current-window-tilte ()
(let ((current-window (current-window)))
(if current-window
(window-title current-window)
(cat "No Window In ::"
(group-name (current-group)) "::"))))


(defun window-tilte-and-notifications-with-fix-length (length notifications-length)
(if (< length notifications-length)
(error "length should bigger than notifications-length!"))
(if notifications
(cat (fix-str-length (current-window-tilte) (- length
notifications-length
3))
" ["
(fix-str-length (format nil "~{ ~a~#[~:;;~]~}" notifications) notifications-length)
"]")
(fix-str-length (current-window-tilte) length)))


(setf *screen-mode-line-format* (list "^5*"
`(:eval (window-tilte-and-notifications-with-fix-length 56 20))
;; "%N" ;notifications
"^n"
"^6*%w ^n"
" %c " ; cpu
`(:eval (check-mail "/home/tsp/Mail/inbox/new/*.*"))
" ^2*"
`(:eval (dswm::format-time-string "%a %b %e %k:%M %Y"))
"^n"))

;; Switch mode-line on
(if (not (head-mode-line (current-head)))
(toggle-mode-line (current-screen) (current-head)))


;; toggle-mode-line-hook
;; (defun toggle-mode-line-hook (key key-seq cmd)
;; (declare (ignore key key-seq cmd))
;; (mode-line))

;; (add-hook *key-press-hook* 'toggle-mode-line-hook)

;; mode-line-click-hook
(defun mode-line-click-hook (ml button x y)
(let* ((head (mode-line-head ml))
(hn (head-number head)))
(run-shell-command (format nil "echo '^fg(red)YOU^fg() CLICKED button:~d x:~d y:~d' | dzen2 -xs ~D -p 3"
button x y
(1+ hn)))))

(replace-hook *mode-line-click-hook* 'mode-line-click-hook)

;;; to start swank
;; (swank-loader:load-swank)
;; (asdf:oos 'asdf:load-op 'swank)
;; (swank:create-server :port 4005 :dont-close t :coding-system "utf-8-unix")
;; Then call slime-connect with defaults from GNU Emacs
;; added swank connection to dswm-command "swank"
(defcommand swank () ()
(setf dswm:*top-level-error-action* :break)
(and (swank:create-server :port swank::default-server-port
:style swank:*communication-style*
:coding-system "utf-8-unix"
:dont-close t))
(echo-string (current-screen) "Starting Swank"))


;; Leaving open the option to use Conkeror, a skin over Firefox.
;; Wish I could get sane tabbed browsing in it...
(defcommand conkeror () ()
"Start/Switchto Conkeror."
(run-or-raise "conkeror" '(:class "Conkeror")))


;;Query ACPI and show the battery's status.
(defcommand show-battery () ()
(echo-string (current-screen) (run-shell-command "acpi" t)))

(defcommand show-mldonkey-stats () ()
(substitute #\Space #\Newline (run-shell-command "(ps aux c | grep -q 'mlnet') && \\
mldonkey_command -p \"\" vd | grep Down: | cut -d'|' -f1,2" t)))

;;Briefly display a single frame from the top command and bind to a key.
;;Inspiration: <http://hocwp.free.fr/temp/dswmrc>
(defcommand run-top () ()
(dswm::my-shell-command "top -b -n 1 -c -d 1"))

(defcommand emacs () ()
"Start emacs unless it is already running, in which case focus it."
(run-or-raise "emacs" '(:class "Emacs")))

(defcommand xpdf () ()
(run-or-raise "xpdf" '(:class "Xpdf")))

;; Binding for Xpdf
(define-key *root-map* (kbd "x") "xpdf")

(defcommand gmrun () ()
(run-shell-command "gmrun"))


(defcommand stardict () ()
(run-or-raise "stardict" '(:class "Stardict")))

;; need to install xautomation
(defcommand stardict-scan-toggle () ()
(dswm::find-window-dwim '(:class "Stardict") :all-groups t
:exec-shell "xte 'keydown Alt_L' 'key s' 'keyup Alt_L'"
:to-and-back t))

(defparameter *dictionary-map*
(let ((m (make-sparse-keymap)))
(define-key m (kbd "ESC") "abort")
(define-key m (kbd "d") "stardict")
(define-key m (kbd "s") "stardict-scan-toggle")
m))

(dswm:define-key dswm:*root-map* (dswm:kbd "d") '*dictionary-map*)

(defcommand toggle-touchpad () ()
"Toggle the laptop touchpad on/off.
Need to have set 'Option SHMConfig' for Synaptics Touchpad
device in xorg.conf."
(let ((state (run-shell-command
"synclient -l | grep TouchpadOff | awk '{ print $3 }'" t)))
(case (string= (subseq state 0 1) "1")
(t (shell-command "synclient TouchpadOff=0"))
(otherwise (shell-command "synclient TouchpadOff=1")
(banish-pointer)))))

;; (define-key *root-map* (kbd "T") "toggle-touchpad")

;; Turn off Touchpad initially
;; (shell-command "synclient TouchpadOff=1")



;; (defun show-prompt ()
;; (format *terminal-io* "~&~A> " (package-name *package*))
;; (force-output *terminal-io*))

;; (add-hook *start-hook* #'show-prompt)

;; (add-hook *internal-loop-hook*
;; (lambda ()
;; (when (listen *terminal-io*)
;; (format t "~{~&~A~}~%"
;; (multiple-value-list
;; (ignore-errors
;; (eval (read *terminal-io*)))))
;; (clear-input *terminal-io*)
;; (show-prompt))))

;;;;;;;;;;;;;;
;;; Building on these, and using the (external) program xautomation, a functional (but ugly and non-native) equivalent to
;; ratpoison's ratclick is possible like so:

(defun ds-send-click (button iterations)
"Send a click to the current pointer location.
`button' is which mouse button to use and `iterations' is how many times to click
(so twice would be a double-click, for example)."
(loop while (> iterations 0) do
(shell-command (cat "xte 'mouseclick " (write-to-string button) "'"))
(setq iterations (- iterations 1))))

(defcommand new-ratclick (button iterations) ((:number "Button: ")
(:number "How many times? "))
(when (current-window)
(ds-send-click button iterations)))

;; I prefer to bind these to a key, since I use a separate keymap for all my mouse control needs. If you provide no
;; argument, it will prompt for both. If you provide one, it'll prompt for the second, and if you provide both it'll
;; just click.

;; (define-key *rat-map* (kbd "s") "new-ratclick 1 1")
;; (define-key *rat-map* (kbd "d") "new-ratclick 2 1")
;; (define-key *rat-map* (kbd "f") "new-ratclick 3 1")
;; (define-key *rat-map* (kbd "S") "new-ratclick 1")
;; (define-key *rat-map* (kbd "D") "new-ratclick 2")
;; (define-key *rat-map* (kbd "F") "new-ratclick 3")
;;;;;;;;;;;;;;;;;

(defcommand reinit () ()
(run-commands "reload" "loadrc"))
;; (defcommand init () ()
;; (dswm::load-rc-file))

(defcommand firefox () ()
(run-or-raise "firefox" '(:class "Firefox")))

(define-key *root-map* (kbd "j") "firefox")

(defcommand urxvt () ()
(run-or-raise "urxvt" '(:class "URxvt")))

(define-key *root-map* (kbd "RET") "urxvt")

(define-key *root-map* (kbd "C-w") "windowlist")

(defcommand dmenu () ()
(run-shell-command "dmenu_run"))
(define-key *root-map* (kbd "P") "dmenu")


(defcommand image-viewer () ()
(run-or-raise X-IMAGE-VIEWER '(:class "Image-viewer")))

;; Automatically dump a core file when we quit. .xinitrc will try to exec ~/bin/sbcl-dswm-core
;; (define-dswm-command "quit" ()
;; (sb-ext:save-lisp-and-die "/home/gwern/bin/sbcl-dswm-core" :executable t :toplevel #'dswm:dswm))

;;; Pasting
;;Loads in some functions to allow multiple registers (think Emacs-style). Binds to numerical keys.
;;See <http://dswm.elektrubadur.se/cgi-bin/wiki/paste.lisp>
;; (load (expand-file-name "~/.dswm.d/paste.lisp"))

;; (defcommand insert-X-selection () ()
;; (window-send-string (current-window) (get-x-selection)))

(defcommand write-selection nil nil
(run-shell-command "xsel -o"))
(define-key *top-map* (kbd "s-y") "write-selection")

;;; about selection

(define-key *root-map* (kbd "M-s") "getsel")

;;; bookmarks
(load (expand-file-name "~/.dswm.d/bookmarks.lisp"))
(define-key *root-map* (kbd "b") '*bookmarks-map*)

;;; cpu
(load-module "cpu")
(setq *cpu-usage-bar-width* 12)

(defun fmt-cpu-usage (ml)
"Returns a string representing current the percent of average CPU
utilization."
(declare (ignore ml))
(let ((cpu (truncate (* 100 (current-cpu-usage)))))
(format nil "CPU:^[~A~3D%^] " (bar-zone-color cpu) cpu)))
;;; cl-keynav
;; (load (expand-file-name "~/.dswm.d/cl-keynav.lisp"))


;;; surfraw
(load-module "surfraw")
(setf *surfraw-bookmark-file* (expand-file-name "~/.surfraw.bookmarks"))

(defparameter *surfraw-map*
(let ((m (make-sparse-keymap)))
(define-key m (kbd "t") "surfraw")
(define-key m (kbd "ESC") "abort")
(define-key m (kbd "g") "google")
(define-key m (kbd "G") "google-selection")
(define-key m (kbd "b") "sr-bookmark")
(define-key m (kbd "B") "sr-bookmark-file-display")
(define-key m (kbd "y") "wayback")
(define-key m (kbd "Y") "wayback-selection")
(define-key m (kbd "w") "wikipedia")
(define-key m (kbd "W") "wikipedia-selection")
m))
(dswm:define-key dswm:*root-map* (dswm:kbd "t") '*surfraw-map*)



;; --------------------------------------------------------------------------------
;; Startup programs
;; --------------------------------------------------------------------------------
;;; What programs do we run on startup?

;; Do some key re-mapping; it is crucial that this get run first, because otherwise
;; the remapping later on of Insert and less to the prefix key simply will not work.
;; (run-shell-command "xmodmap -quiet ~/.Xmodmap")

;; Apparently modifies some low-level GUI bits of X.
;; (run-shell-command "xrdb -load ~/.Xresources -quiet")



(replace-hook *start-hook* 'tsp-start-hook)
(defun tsp-start-hook ()
;; Keep the X cursor out of the way.
;; (run-with-timer 5 5 'banish-pointer)
;; Change the background and pointer in X
(run-shell-command "xsetroot -cursor_name left_ptr -gray -fg black -bg white -name root-window")
(run-shell-command "feh --bg-scale /home/tsp/.wmii-3.5/wallpaper/wmii.jpg")
;; (run-shell-command "xsetbg /home/enigma/media/pictures/artwork/vintage_wallpaper_blue.png")
(run-shell-command "(ps aux c | grep -q 'urxvt') || urxvt")
;; (run-shell-command "(ps aux c | grep -q 'have-a-rest') || have-a-rest")
;; Run unclutter so the mouse hangs around no longer than needed.
(run-shell-command "unclutter -idle 1 -jitter 2 -root")
;; I use Xscreensaver as a screensaver. The first line makes sure any running Xscreensaver is killed.
;; The second run regardless of the success of the first & starts a background Xscreensaver daemon
;; (run-shell-command "xscreensaver-command -exit; killall xscreensaver 2>/dev/null; xscreensaver -no-splash")
;; (run-shell-command "dmenu_path")
(run-shell-command "fcitx"))
;; Have a nice, randomly selected image from my ~/pics directory made the root window background.
;; This is actually a shell script command; one needs the #!/bin/bash shebang in the shell script
;; or an explicit invocation of the shell, like "bash ~/bin/random-picture.sh".
;; (run-shell-command "random-picture")
;; (run-shell-command "bash xsetbg -border black -fork -type png -fit -onroot -fullscreen
;; ~/pics/`w=(*.png); n=${#w[@]}; echo ${w[RANDOM%n]}`") ;full version

;;; This is an alternative- setting Electric Sheep as the background.
;;(run-shell-command "killall electricsheep 2>/dev/null; electricsheep --root 1 --nick gwern --zoom 1 --mplayer 1 --history 50")


;; ----------------------------------------------------------------------------------------------------
;; Key binding
;; ----------------------------------------------------------------------------------------------------
;;; Make the bindings more comfortable.

;;Set the *prefix-key*. The main feature of note is the changing of the escape sequence from 2 keys, c-j, to a single
;;key, and the mirroring of less with another key, so there are actually 2 equivalent escape keys.

(set-prefix-key (kbd "C-i"))

;; When not in Dswm mode, we want Insert to be bound to enter Dswm mode
(define-key *top-map* (kbd "Insert") '*root-map*)
(define-key *root-map* (kbd "Insert") "next") ;;When in Dswm mode, act like hitting the prefix again would.

;; top map
(define-key *top-map* (kbd "H-Tab") "other") ; C-i C-i seems more convenient
(define-key *top-map* (kbd "H-S-ISO_Left_Tab") "prev")
(define-key *top-map* (kbd "H-ISO_Left_Tab") "prev")
;; (define-key *top-map* (kbd "H-^") "gother")



;;; emms
(defvar *emms-bindings*
'(("n" . "emms-next")
("p" . "emms-previous")
("SPC" . "emms-pause")))

(defparameter *emms-map*
(let ((m (make-sparse-keymap)))
(map nil #'(lambda (x)
(define-key m (kbd (car x)) (cdr x)))
*emms-bindings*)
m))
(define-key *root-map* (kbd "e") '*emms-map*)

(define-key *top-map* (kbd "s-n") "emms-next")
(define-key *top-map* (kbd "s-p") "emms-previous")
(define-key *top-map* (kbd "s-SPC") "emms-pause")

(defcommand emms-next () ()
(dswm::find-window-dwim '(:class "Emacs")
:all-groups t
:all-screens t
:exec-shell "emacsclient.emacs22 -e '(emms-next)'"
:do-func '(message "Emms: Next song.")))

(defcommand emms-previous () ()
(dswm::find-window-dwim '(:class "Emacs")
:all-groups t
:all-screens t
:exec-shell "emacsclient.emacs22 -e '(emms-previous)'"
:do-func '(message "Emms: previous song.")))

(defcommand emms-pause () ()
(dswm::find-window-dwim '(:class "Emacs")
:all-groups t
:all-screens t
:exec-shell "emacsclient.emacs22 -e '(emms-pause)'"
:do-func '(message "Emms: Pause.")))

;;; Screenshot
;;Make prtscreen work, as long as in command mode. "import" is an Imagemagick command.
(define-key *top-map* (kbd "Print") "exec import -window root png:$HOME/xwd-$(date +%s)$$.png")
(defcommand part-screenshot () ()
(run-shell-command "scrot -s"))
(define-key *top-map* (kbd "M-Print") "part-screenshot")


;; screen locker
(define-key *root-map* (kbd "L") "exec xlock")
(define-key *root-map* (kbd "M-l") "exec xset dpms force off")


(define-key *root-map* (kbd "ESC") "abort")
;; ;;You remember what run-top did, don't you? Defined in the functions section.
(define-key *root-map* (kbd "&") "run-top")

;;Ditto for show-battery.
(define-key *root-map* (kbd "*") "show-battery")

;;Allow short displays of shell output. Don't run GUI programs through this! Overrides default.
(define-key *root-map* (kbd "!") "my-shell-command")

;; ;;Browse somewhere with the GUI WWW browser.
;; (define-key *root-map* (kbd "b") (cat "colon " X-WWW-BROWSER " http://www."))
(define-key *root-map* (kbd "B") "open-selection-browser")

;;SSH somewhere in the default terminal.
(define-key *root-map* (kbd "C-s") (cat "colon " X-TERM " -e ssh "))

;;More SSH.
(define-key *root-map* (kbd "X") (cat X-TERM "-e ssh -X root@127.0.0.1 urxvt"))

(define-key *root-map* (kbd "C") (cat "colon " X-TERM " -e "))
(define-key *root-map* (kbd "C-j") "emacs")


;; Bindings for minimalistic CLI/GUI web browsers.
(define-key *root-map* (kbd "W") X-TERM-BROWSER)

;;Shortcut for Nano
(define-key *root-map* (kbd "M-E") (cat "colon " X-TERM " -e nano"))

;; Image viewer
(define-key *root-map* (kbd "v") "image-viewer") ;;"image-viewer" is defined in functions.

;;Apparently ds's default does something weird on my latop's screen. This should fix it.
(define-key *root-map* (kbd "s") "vsplit")
(define-key *root-map* (kbd "S") "hsplit")


;; Web browsing commands
;; Get the X selection and order the GUI browser to open it. Presumably it is a HTTP address.
(defcommand open-selection-browser () ()
(run-shell-command (cat X-WWW-BROWSER (get-x-selection))))

;;; Web jump (works for Google and Imdb)
;; (defmacro make-web-jump (name prefix)
;; `(defcommand ,name (search) ((:rest ,(concatenate 'string name " search: ")))
;; (substitute #\+ #\Space search)
;; (run-shell-command (concatenate 'string ,prefix search))))

;; (make-web-jump "google" "firefox http://www.google.fr/search?q=")
;; (make-web-jump "imdb" "firefox http://www.imdb.com/find?q=")



;;; Display the keysequence in progress
(defun key-press-hook (key key-seq cmd)
(declare (ignore key))
(unless (eq *top-map* *resize-map*)
(let ((*message-window-gravity* :bottom-right))
(message "Key sequence: ~A" (print-key-seq (reverse key-seq))))
(when (stringp cmd)
;; Give 'em time to read it.
(sleep 0.1))))
(replace-hook *key-press-hook* 'key-press-hook)


;;; Group
;; Change various group things.

;; Two quick and easy shortcuts - one to switch rapidly between groups and another to list them.
;; Anything more elaborate can be done by going through group-mode.
(define-key *root-map* (kbd "~") "vgroups")
(define-key *root-map* (kbd "quoteleft") "gprev")


;; fixme: the value NIL is not type of DSWM:WINDOW
(defun gmove-window (window)
"Move application to special group"
(dolist (pair '(("URxvt" "Hacking")
("Emacs" "Hacking")
("Firefox" "Hacking")
("Xpdf" "Hacking")
("MPlayer" "Hacking")
("Opera" "Hacking")
("Eva" "Eva")
("Stardict" "Default")))
(if (string= (window-class window) (car pair))
(let ((to-group (find-group (current-screen) (cadr pair))))
(if to-group
(progn (move-window-to-group window to-group)
(return-from gmove-window)))))))
(replace-hook *new-window-hook* 'gmove-window)

;; Call our first group Term, since that's what I usually use in it.
(setf (group-name (first (screen-groups (current-screen)))) "Default")
;;Automatically open up some virtual desktop;
(dswm::run-commands "gnewbg Default"
"gnewbg Hacking"
"gnewbg Eva"
"gselect Hacking")


;; Fluxbox-style Alt-F# virtual desktop (group in DsWM-speak) switching. Modified from:
;; http://hcl-club.lu/svn/development/lisp/.dswmrc
;; (dotimes (i 13)
;; (unless (eq i 0) ; F0 is non-existant and will error.
;; (define-key *top-map* (kbd (format nil "M-F~a" i)) (format nil "gselect ~a" i))))

;; Trash group

;; A couple of functions for "banishing" the current window in a ".trash" group. Since this group is hidden, you can't
;; switch to it with gnext/gprev and it won't appear in vgroups and such (unless *list-hidden-groups* is set). You can
;; show the content of the trash with "trash-show". The group is automatically removed when its last window is destroyed
;; (and recreated on demand).

;; (defvar *trash-group* '()
;; "Group containing the trashed windows")

;; (defun clean-trash (w)
;; "Called when a window is destroyed. If it was the last window of the
;; trash group, destroy it"
;; (let ((current-group (window-group w)))
;; (when *trash-group*
;; (when (and (eq current-group *trash-group*)
;; (not (group-windows current-group)))
;; (if (eq (current-group) *trash-group*)
;; (let ((to-group (second (screen-groups (current-screen)))))
;; (switch-to-group to-group)
;; (kill-group *trash-group* to-group))
;; (kill-group *trash-group* (current-group)))
;; (setf *trash-group* nil)
;; (message "The trash is empty")))))


;; (define-dswm-command "trash-window" ()
;; "Put the current window in the trash group. If it doesn't exist,
;; create it"
;; (unless (or (eq (current-group) *trash-group*)
;; (not (current-window)))
;; (unless *trash-group*
;; (setf *trash-group* (add-group (current-screen) ".trash")))
;; (move-window-to-group (current-window) *trash-group*)))

;; (define-dswm-command "trash-show" ()
;; "Switch to the trash group if it exists, call again to return to
;; the previous group"
;; (if *trash-group*
;; (if (eq (current-group) *trash-group*)
;; (switch-to-group (second (screen-groups (current-screen))))
;; (switch-to-group *trash-group*))
;; (message "The trash is empty!")))


;; (add-hook *destroy-window-hook* #'clean-trash)

;; sample bindings
;; (define-key *root-map* (kbd "_") "trash-window")
;; (define-key *root-map* (kbd "M-SPC") "trash-show")

;;----------------------------------------------------------------------------------------------------
;;; These functions let me use a different keymap for a given amount of seconds.
;;----------------------------------------------------------------------------------------------------
(defvar *th-top-map* *top-map*
"A backup of the *top-map* when dswm started.")

;; #+sbcl
(defparameter th-temporary-top-map-timer
(sb-ext:make-timer (lambda () (th-back-to-top-map)))
"The timer for the temporary *top-map*")

;; #+sbcl
(defun th-use-temporary-top-map (keymap seconds)
(when (sb-ext:timer-scheduled-p th-temporary-top-map-timer)
(sb-ext:unschedule-timer th-temporary-top-map-timer))
(th-push-top-map keymap)
(sb-ext:schedule-timer th-temporary-top-map-timer 2))

(defun th-push-top-map (keymap)
(when (not (eq *top-map* keymap))
(push-top-map keymap)))

(defun th-back-to-top-map ()
(when *top-map-list*
(setf *top-map* *th-top-map*
*top-map-list* nil)
(sync-keys))
(message "return to *top-map*"))


;; -------------------------------------------------------------------------------------------------------------------------
;;; volume control
(load (expand-file-name "~/.dswm.d/vc.lisp"))


;;; window operate
(defparameter *window-operate-map*
(let ((m (make-sparse-keymap)))
(define-key m (kbd "ESC") "abort")
(define-key m (kbd "n") "move-focus down")
(define-key m (kbd "p") "move-focus up")
(define-key m (kbd "b") "move-focus left")
(define-key m (kbd "f") "move-focus right")

(define-key m (kbd "C-n") "move-window down")
(define-key m (kbd "C-p") "move-window up")
(define-key m (kbd "C-b") "move-window left")
(define-key m (kbd "C-f") "move-window right")
(define-key m (kbd "k") "remove")
(define-key m (kbd "0") "remove")
m))

(define-key *root-map* (kbd "w") '*window-operate-map*)


;; ----------------------------------------------------------------------------------------------------
;;; Here there is a small starting applications menu.

(defcommand mymenu () ()
(labels ((pick (options)
(let ((selection (dswm::select-from-menu (current-screen) options "")))
(cond
((null selection)
(throw 'dswm::error "Abort."))
((stringp (second selection))
(second selection))
(t
(pick (cdr selection)))))))
(let ((choice (pick *app-menu*)))
(run-shell-command choice))))

(defparameter *app-menu* '(("BookShelf"
;;submenu
("Concrete Mathematics" "xpdf /mnt/e/Books/Math/ConcreteMath_CN.pdf")
("PraiseForPracticalCommonLisp" "xpdf /mnt/e/Books/CommonLisp/PraiseForPracticalCommonLisp.pdf")
("ANSI Common Lisp" "xpdf '/mnt/e/Books/CommonLisp/Graham, Paul - ANSI Common Lisp.pdf'")
("Instructors.Manual" "xpdf '/mnt/e/Books/Algorithms/Introduction To Algorithms 2nd Edition Solutions (Instructors.Manual).pdf'")
("SolutionsToITA" "xpdf /mnt/e/Books/Algorithms/SolutionsToITA.pdf")
("LispBook" "xpdf /mnt/e/Books/CommonLisp/loveinglisp/LispBook.pdf"))

("INTERNET"
;; sub menu
("Firefox" "firefox")
("opera" "opera"))
("FUN"
;; sub menu
("option 2" "xlogo")
("Crack attack" "crack-attack")
("wesnoth" "wesnoth")
("supertux" "supertux")
("GnuChess" "xboard"))
("WORK"
;;submenu
("OpenOffice.org" "openoffice"))
("GRAPHICS"
;;submenu
("GIMP" "gimp"))))

(define-key *root-map* (kbd ".") "mymenu")
;; ----------------------------------------------------------------------------------------------------

;; This command runs the dswm "quit" command, but only if there aren't any windows open.
(defcommand safequit () ()
"Checks if any windows are open before quitting."
(let ((win-count 0))

;; Count the windows in each group
(dolist (group (screen-groups (current-screen)))
(setq win-count (+ (length (group-windows group)) win-count)))

;; Display the number of open windows or quit
(if (= win-count 0)
(run-commands "quit")
(message (format nil "You have ~d ~a open" win-count
(if (= win-count 1) "window" "windows"))))))



;; (defun open-shell-command-char (stream char)
;; `(quote
;; ,(let ((cmd (read-line stream))
;; list item)
;; (with-input-from-string
;; (str (with-output-to-string (s)
;; (run-program (subseq cmd 0 (- (length cmd) 1))
;; nil
;; :output s)))
;; (loop
;; while (setf item (read-line str nil))
;; do (push item list)))
;; (nreverse list))))

;; (set-macro-character #\[ #'open-shell-command-char)
;; (set-macro-character #\] (get-macro-character #\)))


;;----------------------------------------------------------------------------------------------------
;; Sounds
;;----------------------------------------------------------------------------------------------------
;;; make some souds for special events

;; this will show the curent group name when you will switch the group
(defun focus-group (newg oldg)
(declare (ignore oldg))
(message ":: ~a ::" (group-name newg)))

;; (defun place-window-sound (w g f)
;; (declare (ignore w f))
;; (unless (eq (current-group) g)
;; (interactive-command "exec play /usr/share/sounds/KDE_Drum_Break.ogg")))

;; (defun new-window-sound (w)
;; (interactive-command "exec aplay /usr/share/sounds/KDE_Dialog_Appear.wav"))

;; (defun destroy-window-sound (w)
;; (interactive-command "exec aplay /usr/share/sounds/KDE_Dialog_Disappear.wav"))

(replace-hook *focus-group-hook* 'focus-group)
;; (replace-hook *new-window-hook* 'new-window-sound)
;; (replace-hook *destroy-window-hook* 'destroy-window-sound)
;; (add-hook *place-window-hook* 'place-window-sound)

;; (add-hook *focus-frame-hook* 'frame-hook)


;;; Define window placement policy...
;; Clear rules
(clear-window-placement-rules)

;; Define the gimp command
;; http://dswm.antidesktop.net/wiki/Handling_the_Gimp
;; This macro defines a Dswm command for creating a new group, loading the layout, loading the rules, and starting
;; the program.

;; courtesy of Peter Seibel
(defmacro with-gensyms ((&rest names) &body body)
`(let ,(loop for n in names collect `(,n (gensym)))
,@body))

(defmacro program-with-layout (name &key (command (string-downcase (string name)))
(props `'(:class ,(string-capitalize command))))
(with-gensyms (s w h files-path layout rules)
`(defcommand ,name () ()
(let* ((gname (string-capitalize ,command))
(n-group-windows (if (find-group (current-screen) gname)
(length (group-windows (find-group (current-screen) gname))))))
(cond ((or (null n-group-windows)
(= 0 n-group-windows)) (let* ((,s (current-screen))
(,w (prin1-to-string (screen-width ,s)))
(,h (prin1-to-string (screen-height ,s)))
(,files-path (expand-file-name "~/.dswm.d/"))
(,layout (concat ,files-path ,command "-layout-" ,w "x" ,h))
(,rules (concat ,files-path ,command "-rules")))
(gnew gname)
(restore-from-file ,layout)
(restore-window-placement-rules ,rules)
(run-or-raise ,command ,props)
(place-existing-windows))) ; needed if command was already run
(t (run-or-raise ,command ,props)))))))

(program-with-layout gimp)

;; I keep my layout and rules in ~/dswm.d/. The rules file is named "gimp-rules" and the layout is named depending on
;; screen resolution (e.g., "gimp-layout-1024x768"). The layout loaded will depend on your screen's resolution when you
;; call the newly-defined gimp command.

;; You can call the command like any other regular Dswm command. Use "c-j ; gimp" or bind it to a key with
;; (define-key *root-map* (kbd "G") "gimp").

(program-with-layout eva)
(define-key *root-map* (kbd "c") "eva")

;;----------------------------------------------------------------------------------------------------
;;; No pop-ups
;; Some applications can take a few seconds to load and then pop up suddenly while you are typing away. However dialog
;; boxes in the current application should appear. Put this code in your dswmrc to fix things.


;; (defun window-should-seize-focus (window)
;; (equalp (xlib:get-wm-class (window-xwin window)) "urxvt"))

;; (defun window-in-current-wmgroup (window)
;; (equalp (window-wmgroup window)
;; (window-wmgroup (frame-window (window-frame window)))))

;; (defun window-wmgroup (window)
;; (or (ignore-errors (xlib:wm-hints-window-group (xlib:wm-hints (window-xwin window))))
;; (gensym)))

;; (defgeneric deny-window-request (window deny-list))

;; (defun deny-request-p (window deny-list)
;; (deny-window-request window deny-list))

;; (defmethod deny-window-request (window (deny-list (eql t)))
;; t)

;; (defmethod deny-window-request (window (deny-list sequence))
;; (find-if 'deny-window-request deny-list))

;; (defmethod deny-window-request (window deny-list)
;; (match-res-or-type window deny-list))

;; (defmethod deny-window-request (window (deny-list function))
;; (funcall deny-list window))


;; (setf *deny-raise-request* nil)
;; (setf *deny-map-request*
;; (lambda(window) (not
;; (or (window-in-current-wmgroup window)
;; (window-should-seize-focus window)))))

;; (setf *deny-raise-request* *deny-map-request*)
;; No pop-ups ends there----------------------------------------------------------------------------------------

;; (defvar *maximized-frame-size* (make-frame :x 0 :y 0 :width 1024 :height 600))
;; For a dual screen.
;; (defvar *maximized-frame-size* (make-frame :number -1 :x 1024 :y 0 :width 1024 :height 768))
;; (defvar *maximized-frame-size* (make-frame :number -1 :x 0 :y 0 :width 1024 :height 768))
;; (defvar *current-frame-size* (make-frame :number -1 :x 0 :y 0 :width 0 :height 0))
;; (defvar *current-maximized-frame* nil)



;; (defun maximize-frame (screen frame)
;; (when *current-maximized-frame*
;; (minimize-frame screen))
;; (setf (frame-x *current-frame-size*) (frame-x frame)
;; (frame-y *current-frame-size*) (frame-y frame)
;; (frame-width *current-frame-size*) (frame-width frame)
;; (frame-height *current-frame-size*) (frame-height frame))
;; (setf *current-maximized-frame* frame)
;; (setf (frame-x frame) (frame-x *maximized-frame-size*)
;; (frame-y frame) (frame-y *maximized-frame-size*)
;; (frame-width frame) (frame-width *maximized-frame-size*)
;; (frame-height frame) (frame-height *maximized-frame-size*))
;; (sync-frame-windows screen frame)
;; (dolist (win (screen-mapped-windows screen))
;; (hide-window win))
;; (focus-frame screen frame))



;; (defun minimize-frame (screen)
;; (when *current-maximized-frame*
;; (setf (frame-x *current-maximized-frame*) (frame-x *current-frame-size*)
;; (frame-y *current-maximized-frame*) (frame-y *current-frame-size*)
;; (frame-width *current-maximized-frame*) (frame-width *current-frame-size*)
;; (frame-height *current-maximized-frame*) (frame-height *current-frame-size*))
;; (sync-frame-windows screen *current-maximized-frame*)
;; (setf *current-maximized-frame* nil)
;; (dolist (frame (screen-frames screen))
;; (when (frame-window frame)
;; (unhide-window (frame-window frame))))
;; (focus-frame screen (screen-current-frame screen))))

;; (defun toggle-minmax-frame (screen frame)
;; (if *current-maximized-frame*
;; (minimize-frame screen)
;; (maximize-frame screen frame)))



;; (define-dswm-command "max" (screen)
;; (maximize-frame screen (screen-current-frame screen)))

;; (define-dswm-command "min" (screen)
;; (minimize-frame screen))

;; (define-dswm-command "toggle" (screen)
;; (toggle-minmax-frame screen (screen-current-frame screen)))

;; (define-dswm-command "bdb" (screen)
;; (setf (xlib:window-border (xlib:input-focus *display*))
;; (xlib:screen-black-pixel (screen-number screen))))

;; (define-dswm-command "bdw" (screen)
;; (setf (xlib:window-border (xlib:input-focus *display*))
;; (xlib:screen-white-pixel (screen-number screen))))


;; (define-dswm-command "ce" (screen)
;; (setup-win-gravity screen (frame-window (screen-current-frame screen)) :center))

;;; "Tile two windows horizontally."
;; (define-dswm-command "vt" (screen (win1 :number "Pull: ") (win2 :number "Pull: "))
;; (pull-window-by-number screen win1) ; pull the first window
;; (horiz-split-frame screen) ; split the current frame
;; (focus-frame-sibling screen) ; get the sibling, and pull the second window
;; (pull-window-by-number screen win2))


;; ;;; "Tile two windows vertically."
;; (define-dswm-command "vt" (screen (win1 :number "Pull: ") (win2 :number "Pull: "))
;; (pull-window-by-number screen win1) ; pull the first window
;; (vert-split-frame screen) ; split the current frame
;; (focus-frame-sibling screen) ; get the sibling, and pull the second window
;; (pull-window-by-number screen win2))


;; ;;; Exchange two windows in there frames.
;; (define-dswm-command "ex" (screen (win1 :number "Pull: ") (win2 :number "Pull: "))
;; (pull-window-by-number screen win1)
;; (focus-frame-sibling screen)
;; (pull-window-by-number screen win2)
;; (focus-frame-sibling screen))

;; (define-dswm-command "exchange1" (screen)
;; (let ((n1 (window-number (frame-window (screen-current-frame screen)))))
;; (focus-frame-sibling screen)
;; (let ((n2 (window-number (frame-window (screen-current-frame screen)))))
;; (pull-window-by-number screen n1)
;; (focus-frame-sibling screen)
;; (pull-window-by-number screen n2))))

;; ;;(define-dswm-command "exchange" (screen)
;; ;; (labels ((find-window (frame-number)
;; ;; (find-if (lambda (x)
;; ;; (= frame-number (frame-number (window-frame x))))
;; ;; (screen-mapped-windows screen))))
;; ;; (let ((n1 (find-window (frame-number (screen-current-frame screen)))))
;; ;; (dbg n1))))

;; (define-dswm-command "exchange" (screen)
;; (let ((n1 (frame-windows screen (screen-current-frame screen)))
;; (w1 (frame-window (screen-current-frame screen))))
;; (focus-frame-sibling screen)
;; (let ((n2 (frame-windows screen (screen-current-frame screen)))
;; (w2 (frame-window (screen-current-frame screen))))
;; (dolist (win n1)
;; (pull-window-by-number screen (window-number win)))
;; (frame-raise-window screen (screen-current-frame screen) w1)
;; (focus-frame-sibling screen)
;; (dolist (win n2)
;; (pull-window-by-number screen (window-number win)))
;; (frame-raise-window screen (screen-current-frame screen) w2))))

;;; work with emacsclient
;; see also "~/bin/e"
(defvar *es-win* nil
"to hold the windo called emacsclient")
(defun save-es-called-win ()
(setf *es-win* (current-window)))

(defun return-es-called-win (win)
(let* ((group (window-group win))
(frame (window-frame win))
(old-frame (tile-group-current-frame group)))
(frame-raise-window group frame win)
(focus-all win)
(unless (eq frame old-frame)
(show-frame-indicator group))))

;;; Scratchpad ------------------------------------------------------------------
(defstruct scratchpad
(last-group '())
(group '()))

(defvar *scratchpads* '()
"All scratchpads indexed by screen.")

(defun current-scratchpad ()
(gethash (current-screen) *scratchpads*))

(defun create-scratchpad-group (screen)
(let ((scratchpad-group (add-group screen ".scratchpad")))
(setf (group-number scratchpad-group) 0)
scratchpad-group))

(unless *scratchpads*
;; Create a scratchpad for each screen
(setf *scratchpads* (make-hash-table :test #'eq))
(let ((start-screen (car *screen-list*)))
(loop for i in *screen-list*
do (progn (switch-to-screen i)
(let ((scratchpad-group (create-scratchpad-group i)))
;;Store the scratchpad
(setf (gethash (current-screen)
*scratchpads*)
(make-scratchpad
:group scratchpad-group)))))
(switch-to-screen start-screen)))

(defcommand scratchpad () ()
(let ((scratchpad (current-scratchpad)))
(if scratchpad
(cond
((scratchpad-last-group scratchpad)
(switch-to-group (scratchpad-last-group scratchpad))
(setf (scratchpad-last-group scratchpad) nil))
((eq (current-group) (scratchpad-group scratchpad))
(message "scratchpad: I don't know where home is"))
(t
(setf (scratchpad-last-group scratchpad) (current-group))
(switch-to-group (scratchpad-group scratchpad))
(message "scratchpad")))
(message "No scratchpad for this screen."))))


(define-key *root-map* (kbd "SPC") "scratchpad")


;;; file: menu.lisp
(setf *menu-map*
(let ((m (make-sparse-keymap)))
(define-key m (kbd "C-p") 'menu-up)
(define-key m (kbd "Up") 'menu-up)
(define-key m (kbd "p") 'menu-up)

(define-key m (kbd "C-n") 'menu-down)
(define-key m (kbd "Down") 'menu-down)
(define-key m (kbd "n") 'menu-down)
(define-key m (kbd "C-g") 'menu-abort)
(define-key m (kbd "ESC") 'menu-abort)
(define-key m (kbd "RET") 'menu-finish)
(define-key m (kbd "C-j") 'menu-finish)
m))

;;; file: user.lisp
(defcommand eval-line (cmd) ((:rest "DSWM-USER> "))
(handler-case
(message "^20~{~a~^~%~}"
(mapcar 'prin1-to-string
(multiple-value-list (eval (read-from-string cmd)))))
(error (c)
(err "^B^1*~A" c))))

(defun run-or-raise (cmd props &optional (all-groups *run-or-raise-all-groups*) (all-screens *run-or-raise-all-screens*))
"Run the shell command, @var{cmd}, unless an existing window
matches @var{props}. @var{props} is a property list with the following keys:

@table @code
@item :class
Match the window's class.
@item :instance
Match the window's instance or resource-name.
@item :role
Match the window's @code{WM_WINDOW_ROLE}.
@item :title
Match the window's title.
@end table

By default, the global @var{*run-or-raise-all-groups*} decides whether
to search all groups or the current one for a running
instance. @var{all-groups} overrides this default. Similarily for
@var{*run-or-raise-all-screens*} and @var{all-screens}."
(labels
;; Raise the window win and select its frame. For now, it
;; does not select the screen.
((goto-win (win)
(let* ((group (window-group win))
(frame (window-frame win))
(old-frame (tile-group-current-frame group)))
(frame-raise-window group frame win)
(focus-all win)
(unless (eq frame old-frame)
(show-frame-indicator group))))
(find-window (group)
(find-if (lambda (w)
(apply 'window-matches-properties-p w props))
(group-windows group))))
(let*
((screens (if all-screens
*screen-list*
(list (current-screen))))
(win
;; If no qualifiers are set don't bother looking for a match.
;; search all groups
(if all-groups
(loop named outer
for s in screens
do (loop
for g in (screen-groups s)
for win = (find-window g)
when win
do (return-from outer win)))
(find-window (current-group)))))
(if win
(goto-win win)
(progn (run-shell-command cmd)
(message "Now ~a is Loading!" cmd))))))

;;; file: command.lisp
(defcommand colon (&optional initial-input) (:rest)
"Read a command from the user. @var{initial-text} is optional. When
supplied, the text will appear in the prompt."
(let ((cmd (completing-read (current-screen) "DSWM-USER: " (all-commands) (or initial-input ""))))
(unless cmd
(throw 'error :abort))
(when (plusp (length cmd))
(eval-command cmd t))))



;;; -- core.lisp ---------------------------------------------------------

;; Local Variables: **
;; mode:lisp **
;; outline-regexp: ";;; " **
;; End: **