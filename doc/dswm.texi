\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename dswm.info
@settitle DSWM Manual
@setchapternewpage odd
@c %**end of header

@dircategory X11
@direntry
* DSWM: (dswm).       A Common Lisp window manager
@end direntry

@ifinfo
This is the Deep Space Window Manager user manual.

Copyright @copyright{} 2000-2008 Shawn Betts

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

@ignore
Permission is granted to process this file through TeX
and print the results, provided the printed document
carries a copying permission notice identical to this
one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.
@end ifinfo

@iftex
@kbdinputstyle code
@end iftex

@titlepage
@sp 10
@titlefont{The Deep Space Window Manager}
@author Alexander Vynnyk

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2000-2008 Shawn Betts

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.
@end titlepage

@node Top, Introduction, (dir), (dir)

@ifinfo
This document explains how to use The Deep Space Window Manager.
@end ifinfo

@menu
* Introduction::                
* Key Bindings::                
* Commands::                    
* Message and Input Bar::       
* Windows::                     
* Frames::                      
* Mode-line::                   
* Groups::                      
* Screens::                     
* Interacting With Unix::       
* Interacting With X11::        
* Miscellaneous Commands::      
* Colors::                      
* Hooks::                       
* Modules::                     
* Hacking::                     
* Command and Function Index::  
* Variable Index::              

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Starting DSWM::            
* Basic Usage::                 
* Interacting with the Lisp process::  
* Contact the DSWM developers::  

Key Bindings

* List of Default Keybindings::  
* Binding Keys::                
* Modifiers::                   

Message and Input Bar

* Customizing The Bar::         
* Using The Input Bar::         
* Programming The Message Bar::  
* Programming the Input Bar::   

Windows

* Window Marks::                
* Customizing Window Appearance::  
* Controlling Raise And Map Requests::  
* Programming With Windows::    
* Rule Based Window Placement::  
* Remember-Forget-Recall Subsystem::  

Frames

* Interactively Resizing Frames::  
* Frame Dumping::               

Groups

* Customizing Groups::          

Screens

* Xinerama::                    
* Programming With Screens::    

Miscellaneous Commands

* Menus::                       
* DSWM's Data Directory::    
* Debugging DSWM::           
* Timers::                      
* Getting Help::                

Colors

* Behind The Scenes Look At Colors::  

Hacking

* General Advice::              
* Using git with DSWM::      
* Sending Patches::             

@end detailmenu
@end menu

@node Introduction, Key Bindings, Top, Top
@chapter Introduction
DSWM is an X11 window manager written entirely in Common Lisp. Its
user interface goals are similar to ratpoison's but with an emphasis on
customizability, completeness, and cushiness.

@menu
* Starting DSWM::            
* Basic Usage::                 
* Interacting with the Lisp process::  
* Contact the DSWM developers::  
@end menu

@node Starting DSWM, Basic Usage, Introduction, Introduction
@section Starting DSWM
There are a number of ways to start DSWM but the most straight
forward method is as follows. This assumes you have a copy of the
DSWM source code and are using the @samp{SBCL} Common Lisp
environment.

@enumerate
@item
Install @command{sbcl}, the @command{portable-clx} package, and
@command{cl-ppcre}. In Debian, @command{portable-clx} is the
@command{cl-clx-sbcl} package. You can also use @command{asdf-install} to
download and install@tie{}@command{clx}:

@example
$ sbcl
* (require :asdf)
* (require :asdf-install)
* (asdf-install:install :clx)
* (asdf-install:install :cl-ppcre)
@end example

Note that @command{asdf-install} requires @command{gnupg}.

@item
In the @file{dswm} directory, run @command{./configure}.

@item
run @command{make}. If all goes well,
this should create a @file{dswm} executable.

@item
In your @file{~/.xinitrc} file include the line
@command{/path/to/dswm}. Remember to replace @samp{/path/to/}
with the actual path.

@item
Finally, start X windows with @command{startx}. Cross your
fingers. You should see a @samp{Welcome To the Deep Space Window Manager}
message pop up in the upper, right corner. At this point, you have
successfully started DSWM.
@end enumerate

@node Basic Usage, Interacting with the Lisp process, Starting DSWM, Introduction
@section Some definitions
In this manual we will use some special definitions:

@subsection Key sequences
@kbd{PREF} - means prefix keyboard sequence. It is @kbd{Control + j} by default
@kbd{C-k}  - means, that you have to press keys ``Control'' and ``k'' at one time
@kbd{M-k}  - means, that you have to press keys ``Alt and ``k'' at one time
@kbd{S-k}  - means, that you have to press keys ``Shift'' and ``k'' at one time
@kbd{C-K}  - means, that you have to press keys ``Control'', ``Shift'' and ``k'' at one time
@kbd{s-k}  - means, that you have to press keys ``Windows''-key (``super'') and ``k'' at one time
@kbd{PREF g k}  - means, that you have to press prefix key sequence, then press ``g'' and then press ``k''

@section Basic Usage
Once you have DSWM up and running, the first thing you might want
to do is start @command{emacs}. Type @kbd{PREF e}, or in other words
@kbd{Control + j} followed by @kbd{e}. Now perhaps you want an
@command{xterm}. Type @kbd{PREF c}. Now you have some programs running.

To see a list of windows DSWM is managing, type @kbd{PREF w}. The
highlighted window is the one you're looking at right now. It's the
focused window.

All of DSWM's keys are bound to named commands, which can be
executed not only by keys but also from the input bar. Type @kbd{PREF
;} to open a command prompt. Now type @command{time} and press
return. Note, @command{time} can also be called by typing @kbd{PREF a}.
Throughout this manual you'll find definitions for commands,
functions, and variables. Any command you see in this manual can be
executed from the input bar or bound to a key.

At this point you probably want to switch back from your new
@command{xterm} to @command{emacs}. Type @kbd{PREF PREF}. This runs the
@command{other} command. Type it again and you're back to xterm.

Perhaps you'd like to see @command{emacs} and @command{xterm}
side-by-side. Type @kbd{PREF s}. You have now split the screen into 2
@command{frames}. For more information see @ref{Frames}. To switch to the
empty frame type @kbd{PREF TAB}. Now let's pull the xterm window into
this empty frame. Type @kbd{PREF w} for a window listing. Find the
@command{xterm} window. See the number beside it? Type @kbd{PREF} followed
by @command{xterm}'s window number.

Another common activity is browsing the interwebs. Type @kbd{PREF !}.
The input bar pops up again. You can now run a shell command.  Let's
start a web browser: type @command{firefox} into the input bar and press
return.

Unfortunately, @command{firefox} probably isn't wide enough because it's
in one of the frames. Type @kbd{PREF Q} to remove all frames but the
current one and resize it to fit the screen.

For a full list of key bindings, see @ref{List of Default Keybindings}.

@node Interacting with the Lisp process, Contact the DSWM developers, Basic Usage, Introduction
@section Interacting with the Lisp process

Since DSWM is a Lisp program, there is a way for you to evaluate
Lisp code directly, on the same Lisp process that DSWM is running on.
Type @kbd{PREF :} and an input box will appear. Then type some Lisp
expression.

When you call @command{eval} this way, you will be in the DSWM-USER
package, which imports all the exported symbols from the main DSWM
package.

@table @code
@item *mode-line-border-width*
Reads the value of @var{*mode-line-border-width*}.

@item (setf *mode-line-border-width* 3)
Sets the variable @var{*mode-line-border-width*} to 3.

@item (set-prefix-key (kbd "C-M-H-s-z"))
Calls the @code{set-prefix-key} function (and sets a new keyboard prefix)
@end table


@node Contact the DSWM developers,  , Interacting with the Lisp process, Introduction
@section Contact the DSWM developers
The DSWM home page is @url{http://dswm.nongnu.org/}.

You can reach Shawn Betts at @email{sabetts at vcn.bc.ca}.

The DSWM mailing list is @email{dswm-devel@@nongnu.org} which
you can subscribe to at
@url{http://mail.nongnu.org/mailman/listinfo/dswm-devel}. Posting
is restricted to subscribers to keep spam out of the archives.

The DSWM IRC channel can be found on Freenode at
@uref{irc://irc.freenode.net/#dswm, @code{#dswm}}.

@node Key Bindings, Commands, Introduction, Top
@chapter Key Bindings
DSWM is controlled entirely by keystrokes and Lisp commands. It
mimics GNU Screen's keyboard handling. DSWM's default prefix key is
@kbd{PREF}.

@menu
* List of Default Keybindings::  
* Binding Keys::                
* Modifiers::                   
@end menu

@node List of Default Keybindings, Binding Keys, Key Bindings, Key Bindings
@section List of Default Keybindings
The following is a list of keybindings.

@table @kbd
@item PREF @var{d}
Select the window with the corresponding digit@tie{}@var{d}

@item PREF C-@var{d}
Pull the window with the corresponding digit@tie{}@var{d} into the current frame

@item PREF n
@itemx PREF C-n
@itemx PREF Space
Go to the next window in the window list

@item PREF p
@itemx PREF C-p
Go to the previous window in the window list

@item PREF '
Go to a window by name

@item PREF "
Select a window from a list and focus the window.

@item PREF C-g
Abort the current command. This is useful if you accidentally hit @kbd{PREF}

@item PREF w
List all the windows

@item PREF i
Display information about the current window.

@item PREF f
Select a frame by number

@item PREF s
Split current frame vertically

@item PREF S
Split current frame horizontally

@item PREF k
@itemx PREF C-k
Sends a kill message to the current frame and the running program.

@item PREF K
Kills the current frame and running program; like a @command{kill -9}.

@item PREF c
@itemx PREF C-c
Run an X terminal; by default @command{xterm}

@item PREF e
@itemx PREF C-e
Run Emacs or raise it if it is already running.

@item PREF t
Sends a @kbd{PREF} to the frame; this is useful for applications like Firefox
which make heavy use of @kbd{PREF} (in Firefox's case, for opening a new
tab). This is similar to how GNU screen uses @kbd{C-a a}.

@item PREF w
@itemx PREF C-w
Prints out a list of the windows, their number, and their name.

@item PREF b
@itemx PREF C-b
Runs your default browser.

@item PREF a
@itemx PREF C-a
Display the current time and date, much like the Unix command @command{date}.

@item PREF PREF
Switch to the last window to have focus in the current frame.

@item PREF !
Prompt for a shell command to run via @file{/bin/sh}. All output is discarded.

@item PREF R
If the screen is split into multiple frames, one split will be
undone. If there is only one split, the effect will be the same as @kbd{PREF Q}.

@item PREF o
@itemx PREF TAB
If the screen is split into multiple frames, focus shifts to the
@command{next} frame, where it cycles to the right and then down; analogous
to @kbd{C-x o} in Emacs.

@item PREF F
Display ``Current Frame'' in the frame which has focus.

@item PREF ;
Opens the input box. DSWM commands can be run from here, and the
input history moved through.

@item PREF :
Opens the input box, but all things typed in here will be sent to the
Common Lisp interpreter where they will be ran as Lisp programs; thus,
input should be valid Common Lisp.

@item PREF C-h
The short help and basic DSWM information about system and default directories.
@item PREF ?
The help.

@item PREF -
Hide all frames and show the root window.

@item PREF Q
Removes all splits and maximizes the frame with focus.

@item PREF Up
@itemx PREF Down
@itemx PREF Left
@itemx PREF Right
Shift focus to an adjacent frame in the specified direction. @kbd{PREF Up} will
shift focus up, if possible, @kbd{PREF Down} will shift downwards, etc.

@item PREF v
Prints out the version of the running DSWM.

@item PREF #
Toggle the mark on the current window

@item PREF m
@itemx PREF C-m
Display the last message. Hitting this keybinding again displays the
message before that, and so on.

@item PREF l
@itemx PREF C-l
redisplay the current window and force it to take up the entire frame.

@item PREF G
Display all groups and windows in each group. For more information see @ref{Groups}.

@item PREF F@var{n}
Jump to the corresponding group @var{n}. @kbd{PREF F1} jumps to group 1 and so on.
J
@item PREF g g
Show the list of groups.

@item PREF g c
Create a new group.

@item PREF g n
@itemx PREF g C-n
@itemx PREF g SPC
@itemx PREF g C-SPC
Go to the next group in the list.

@item PREF g !
Prompt for a shell command to run via @file{/bin/sh} in new group with same name. All output is discarded.

@item PREF g \@
Prompt for a shell command to run via @file{/bin/sh} in new float group with same name. All output is discarded.

@item PREF g n
@itemx PREF g C-n
Go to the next group in the list.

@item PREF g N
Go to the next group in the list and bring the current window along.

@item PREF g p
@itemx PREF g C-p
Go to the previous group in the list.

@item PREF g P
Go to the previous group in the list and bring the current window along.

@item PREF g '
Select a group by name or by number.

@item PREF g "
Select a group from a list and switch to it.

@item PREF g m
Move the current window to the specified group.

@item PREF g k
Kill the current group. All windows are merged into the next group.

@item PREF g A
@itemx PREF g r
Change the current group's name.

@item PREF g @var{d}
Go to the group with digit @var{d}. @kbd{PREF g 1} jumps to group 1 and so on.

@item PREF +
Make frames the same height or width in the current frame's subtree.

@item PREF h k
Describe the specified key binding.

@item PREF h f
Describe the specified function.

@item PREF h v
Describe the specified variable.

@item PREF h w
List all key sequences that are bound to the specified command

@item PREF h c
Describe the specified command.
@end table

@node Binding Keys, Modifiers, List of Default Keybindings, Key Bindings
@section Binding Keys

@defun {define-key} map key command
Add a keybinding mapping for the key, @var{key}, to the command,
@var{command}, in the specified keymap. If @var{command} is nil, remove an
exising binding.  For example,

@example
(dswm:define-key dswm:*root-map* (dswm:kbd "C-z") "echo Zzzzz...")
@end example

Now when you type c-j C-z, you'll see the text ``Zzzzz...'' pop up.
@end defun

@defun {undefine-key} map key
Clear the key binding in the specified keybinding.
@end defun

@defun {kbd} keys
This compiles a key string into a key structure used by
`define-key', `undefine-key', `set-prefix-key' and
others.
@end defun

@deffn {Command} set-prefix-key key
Change the dswm prefix key to KEY.
@example
(dswm:set-prefix-key (dswm:kbd "C-M-H-s-z"))
@end example

This will change the prefix key to @key{Control} + @key{Meta} + @key{Hyper} + @key{Super} +
the @key{z} key. By most standards, a terrible prefix key but it makes a
great example.
@end deffn


@defun {make-sparse-keymap} 
Create an empty keymap. If you want to create a new list of bindings
in the key binding tree, this is where you start. To hang frame
related bindings off @kbd{c-j C-f} one might use the following code:

@example
(defvar *my-frame-bindings*
  (let ((m (dswm:make-sparse-keymap)))
    (dswm:define-key m (dswm:kbd "f") "curframe")
    (dswm:define-key m (dswm:kbd "M-b") "move-focus left")
    m ; NOTE: this is important
  ))

(dswm:define-key dswm:*root-map* (dswm:kbd "C-f") '*my-frame-bindings*)
@end example
@end defun


@defvar *root-map*
This is the keymap by default bound to @kbd{C-j}. It is known as the @dfn{prefix map}.
@end defvar

@defvar *top-map*
The top level key map. This is where you'll find the binding for the
@dfn{prefix map}.
@end defvar

@defvar *groups-map*
The keymap that group related key bindings sit on. It is bound to @kbd{C-j g} by default.
@end defvar


@deffn {Command} bind key command
Hang a key binding off the escape key.
@end deffn


@node Modifiers,  , Binding Keys, Key Bindings
@section Modifiers

Many users have had some difficulty with setting up modifiers for
DSWM keybindings. This is caused by a combination of how DSWM
handles modifiers and the default modifiers list for many users' X
servers.

@itemize

@item
My ``Super'' key doesn't work!

This is most likely caused by having the Hyper and Super keys listed
as the same modifier in the modifier list.

@example
$ xmodmap
xmodmap:  up to 3 keys per modifier, (keycodes in parentheses):

shift       Shift_L (0x32),  Shift_R (0x3e)
lock        Caps_Lock (0x42)
control     Control_L (0x25),  Control_R (0x6d)
mod1        Alt_L (0x40),  Alt_R (0x71),  Meta_L (0x9c)
mod2        Num_Lock (0x4d)
mod3
mod4        Super_L (0x7f),  Hyper_L (0x80)
mod5        Mode_switch (0x5d),  ISO_Level3_Shift (0x7c)
@end example

The problem is in the line beginning with ``mod4''. The way to set up
the modifier list correctly is to have just the Super key as the mod4
modifier. The following @command{xmodmap} commands will do just that.

@example
# clear out the mod4 modifier
$ xmodmap -e 'clear mod4'
$ xmodmap
xmodmap:  up to 3 keys per modifier, (keycodes in parentheses):

shift       Shift_L (0x32),  Shift_R (0x3e)
lock        Caps_Lock (0x42)
control     Control_L (0x25),  Control_R (0x6d)
mod1        Alt_L (0x40),  Alt_R (0x71),  Meta_L (0x9c)
mod2        Num_Lock (0x4d)
mod3
mod4
mod5        Mode_switch (0x5d),  ISO_Level3_Shift (0x7c)

# add Super as a mod4 modifier
$ xmodmap -e 'add mod4 = Super_L'
$ xmodmap
xmodmap:  up to 3 keys per modifier, (keycodes in parentheses):

shift       Shift_L (0x32),  Shift_R (0x3e)
lock        Caps_Lock (0x42)
control     Control_L (0x25),  Control_R (0x6d)
mod1        Alt_L (0x40),  Alt_R (0x71),  Meta_L (0x9c)
mod2        Num_Lock (0x4d)
mod3
mod4        Super_L (0x73),  Super_L (0x7f)
mod5        Mode_switch (0x5d),  ISO_Level3_Shift (0x7c)
@end example

You can automate this by storing the commands in a file and calling
xmodmap when you start your X session.

@example
$ cat ~/.Xmodmap
clear mod4
add mod4 = Super_L
@end example

If you use @command{startx}, modify your @file{~/.xsession} or @file{~/.xinitrc} file.

@example
$ cat ~/.xsession
#!/bin/sh

xmodmap ~/.Xmodmap
exec /usr/bin/dswm
@end example

If you use a graphical login manager (GDM, KDM, etc.), your @file{~/.Xmodmap}
file should be fed to @command{xmodmap} when you log in. FIXME: verify this.

@item
Handling Meta and Alt: when do I use @kbd{M-} and @kbd{A-}?

If you have no Meta keys defined (see the output of the @command{xmodmap}
command), then DSWM will treat the @kbd{M-} prefix in keybindings to
mean Alt. However, if there are Meta keys defined, then the @kbd{M-}
prefix refers to them, and the @kbd{A-} prefix refers to Alt.

Most users will simply use @kbd{M-} to refer to their Alt keys. However,
users that define separate Meta and Alt keys will use @kbd{M-} to refer
to the former, and @kbd{A-} to refer to the latter.

@item
How can I set up a Hyper key and use it with DSWM?

To set up a Hyper key, you need to do two things: bind a physical key
to be a Hyper key, and add that key to the modifiers list.

The following example shows how to bind the control key at the
bottom-left of most keyboards to be Hyper. This is useful if you've
made Caps Lock into a control key, and have no use for the bottom-left
key.

@example
$ xmodmap -e 'keycode 37 = Hyper_L'
$ xmodmap -e 'clear mod5'
$ xmodmap -e 'add mod5 = Hyper_L'
@end example

To use a different key for Hyper, replace the keycode ``37'' above.
Use the @command{xev} program to see the keycode that any physical key has.
Refer to the section above on setting up the Super key to see how to
automate setting the Hyper key when you start X.

Now you can use @kbd{H-} as a prefix in DSWM bindings.

@example
(define-key *top-map* (kbd "H-RET") "fullscreen")
(define-key *top-map* (kbd "H-Left") "gprev")
(define-key *top-map* (kbd "H-Right") "gnext")
(define-key *top-map* (kbd "H-TAB") "other")
@end example

Since essentially no programs have Hyper bindings, you can safely bind
commands to the @var{*top-map*}.

@end itemize

@node Commands, Message and Input Bar, Key Bindings, Top
@chapter Commands
If you've used emacs before you'll find commands and functions
familiar. Commands are functions that can be bound to keys and
executed interactively from DSWM's input bar. A command expects a
certain number of arguments and any that are not supplied will be
prompted for.

FIXME: actually write some docs here

@node Message and Input Bar, Windows, Commands, Top
@chapter Message and Input Bar

@deffn {Command} echo string
Display @var{string} in the message bar.
@end deffn

@deffn {Command} colon &optional initial-input
Read a command from the user. @var{initial-text} is optional. When
supplied, the text will appear in the prompt.
@end deffn


@menu
* Customizing The Bar::         
* Using The Input Bar::         
* Programming The Message Bar::  
* Programming the Input Bar::   
@end menu

@node Customizing The Bar, Using The Input Bar, Message and Input Bar, Message and Input Bar
@section Customizing The Bar
The bar's appearance and behavior can be modified with the following
functions and variables.

@defun {set-fg-color} color
Set the foreground color for the message bar and input
bar. @var{color} can be any color recognized by X.
@end defun

@defun {set-bg-color} color
Set the background color for the message bar and input
bar. @var{color} can be any color recognized by X.
@end defun

@defun {set-border-color} color
Set the border color for the message bar and input
bar. @var{color} can be any color recognized by X.
@end defun

@defun {set-msg-border-width} width
Set the border width for the message bar and input
bar.
@end defun

@defun {set-font} font
Set the font for the message bar and input bar.
@end defun


@defvar *message-window-padding*
The number of pixels that pad the text in the message window.
@end defvar

@defvar *message-window-gravity*
This variable controls where the message window appears. The follow
are valid values.
@table @asis
@item :top-left
@item :top-right
@item :bottom-left
@item :bottom-right
@item :center
@end table
@end defvar

@defvar *timeout-wait*
Specifies, in seconds, how long a message will appear for. This must
be an integer.
@end defvar

@defvar *input-window-gravity*
This variable controls where the input window appears. The follow
are valid values.
@table @asis
@item :top-left
@item :top-right
@item :bottom-left
@item :bottom-right
@item :center
@end table
@end defvar


@node Using The Input Bar, Programming The Message Bar, Customizing The Bar, Message and Input Bar
@section Using The Input Bar

The following is a list of keybindings for the Input Bar. Users of Emacs
will recognize them.

@table @kbd
@item DEL
Delete the character before point (@code{delete-backward-char}).

@item M-DEL
Kill back to the beginning of the previous word (@code{backward-kill-word}).

@item C-d
@itemx Delete
Delete the character after point (@code{delete-forward-char}).

@item M-d
Kill forward to the end of the next word (@code{forward-kill-word}).

@item C-f
@itemx Right
Move forward one character (@code{forward-char}).

@item M-f
Move forward one word (@code{forward-word}).

@item C-b
@itemx Left
Move backward one character (@code{backward-char}).

@item M-b
Move backward one word (@code{backward-word}).

@item C-a
@itemx Home
Move to the beginning of the current line (@code{move-beginning-of-line}).

@item C-e
@itemx End
Move to the end of the current line (@code{move-end-of-line}).

@item C-k
Kill to the end of the line (@code{kill-line}).

@item C-u
Kill to the beginning of the line (@code{kill-to-beginning}),
the same as @kbd{C-a C-k}.

@item C-p
@itemx Up
Move to the next earlier entry saved in the command history (@command{history-back}).

@item C-n
@itemx Down
Move to the next later entry saved in the command history (@command{history-forward}).

@item RET
Submit the entered command (@command{submit}).

@item C-g
Abort the current action by closing the Input Bar (@command{abort}).

@item C-y
Paste text from clipboard into the Input Bar (@command{yank-selection}).

@item TAB
Clockwise tab complete the current string, if possible. Press @kbd{TAB} again to
cycle through completions.
 
@item S-TAB
Counter-clockwise tab complete the current string, if possible. Press @kbd{S-TAB} again to
cycle through completions.

@end table

@node Programming The Message Bar, Programming the Input Bar, Using The Input Bar, Message and Input Bar
@section Programming The Message Bar

@defun {echo-string} screen msg
Display @var{string} in the message bar on @var{screen}. You almost always want to use @command{message}.
@end defun

@defun {message} fmt &rest args
run FMT and ARGS through `format' and echo the result to the current screen.
@end defun

@defvar *input-history-ignore-duplicates*
Do not add a command to the input history if it's already the first in the list.
@end defvar

@deffn {Command} copy-last-message 
Copy the last message displayed into the X selection
@end deffn


@node Programming the Input Bar,  , Programming The Message Bar, Message and Input Bar
@section Programming the Input Bar
New input behavior can be added to the input bar by creating editing
functions and binding them to keys in the @var{*input-map*} using
@command{define-key}, just like other key bindings.

An input function takes 2 arguments: the input structure and the key pressed.

@defun {read-one-line} screen prompt &key (initial-input ) require-match password
Read a line of input through dswm and return it. returns nil if the user aborted.
@end defun

@defun {read-one-char} screen
Read a single character from the user.
@end defun

@defun {completing-read} screen prompt completions &key (initial-input ) require-match
Read a line of input through dswm and return it with TAB
completion. completions can be a list, an fbound symbol, or a
function. if its an fbound symbol or a function then that function is
passed the substring to complete on and is expected to return a list
of matches. If require-match argument is non-nil then the input must
match with an element of the completions.
@end defun

@defun {input-insert-string} input string
Insert @var{string} into the input at the current
position. @var{input} must be of type @var{input-line}. Input
functions are passed this structure as their first argument.
@end defun

@defun {input-insert-char} input char
Insert @var{char} into the input at the current
position. @var{input} must be of type @var{input-line}. Input
functions are passed this structure as their first argument.
@end defun


@defvar *input-map*
This is the keymap containing all input editing key bindings.
@end defvar


@node Windows, Frames, Message and Input Bar, Top
@chapter Windows

@deffn {Command} next 
Go to the next window in the window list.
@end deffn

@deffn {Command} pull-hidden-next 
Pull the next hidden window into the current frame.
@end deffn

@deffn {Command} prev 
Go to the previous window in the window list.
@end deffn

@deffn {Command} pull-hidden-previous 
Pull the next hidden window into the current frame.
@end deffn

@deffn {Command} delete-window &optional (window (current-window))
Delete a window. By default delete the current window. This is a
request sent to the window. The window's client may decide not to
grant the request or may not be able to if it is unresponsive.
@end deffn

@deffn {Command} kill-window &optional (window (current-window))
Tell X to disconnect the client that owns the specified
window. Default to the current window. if
@command{delete-window} didn't work, try this.
@end deffn

@deffn {Command} other-window &optional (group (current-group))
Switch to the window last focused.
@end deffn

@deffn {Command} pull-hidden-other 
Pull the last focused, hidden window into the current frame.
@end deffn

@deffn {Command} renumber nt &optional (group (current-group))
Change the current window's number to the specified number. If another window
is using the number, then the windows swap numbers. Defaults to current group.
@end deffn

@deffn {Command} meta key
Send a fake key to the current window. @var{key} is a typical DSWM key, like @kbd{C-M-o}.
@end deffn

@deffn {Command} select-window query
Switch to the first window that starts with @var{query}.
@end deffn

@deffn {Command} select-window-by-number num &optional (group (current-group))
Find the window with the given number and focus it in its frame.
@end deffn

@deffn {Command} title title
Override the current window's title.
@end deffn

@deffn {Command} windowlist &optional (fmt *window-format*)
Allow the user to Select a window from the list of windows and focus
the selected window. For information of menu bindings
@xref{Menus}. The optional argument @var{fmt} can be specified to
override the default window formatting.
@end deffn

@deffn {Command} fullscreen 
Toggle the fullscreen mode of the current widnow. Use this for clients
with broken (non-NETWM) fullscreen implemenations, such as any program
using SDL.
@end deffn

@deffn {Command} window-info &optional (fmt *window-info-format*)
Display information about the current window.
@end deffn

@deffn {Command} refresh 
Refresh current window without changing its size.
@end deffn

@deffn {Command} redisplay 
Refresh current window by a pair of resizes, also make it occupy entire frame.
@end deffn


@defvar *window-format*
This variable decides how the window list is formatted. It is a string
with the following formatting options:

@table @asis
@item %n
Substitutes the windows number translated via *window-number-map*, if there
are more windows than *window-number-map* then will use the window-number.
@item %s
Substitute the window's status. * means current window, + means last
window, and - means any other window.
@item %t
Substitute the window's name.
@item %c
Substitute the window's class.
@item %i
Substitute the window's resource ID.
@item %m
Draw a # if the window is marked.
@end table

Note, a prefix number can be used to crop the argument to a specified
size. For instance, @samp{%20t} crops the window's title to 20
characters.
@end defvar

@defvar *window-name-source*
This variable controls what is used for the window's name. The default is @code{:title}.

@table @code
@item :title
Use the window's title given to it by its owner.

@item :class
Use the window's resource class.

@item :resource-name
Use the window's resource name.
@end table
@end defvar

@defvar *new-window-prefered-frame*
nil
@end defvar


@menu
* Window Marks::                
* Customizing Window Appearance::  
* Controlling Raise And Map Requests::  
* Programming With Windows::    
* Rule Based Window Placement::  
* Remember-Forget-Recall Subsystem::  
@end menu

@node Window Marks, Customizing Window Appearance, Windows, Windows
@section Window Marks
Windows can be marked. A marked window has a # beside it in the window
list. Some commands operate only on marked windows.

@deffn {Command} mark 
Toggle the current window's mark.
@end deffn

@deffn {Command} clear-window-marks &optional (group (current-group)) (windows
                                                                       (group-windows
                                                                        group))
Clear all marks in the current group.
@end deffn

@deffn {Command} pull-marked 
Pull all marked windows into the current frame and clear the marks.
@end deffn


@node Customizing Window Appearance, Controlling Raise And Map Requests, Window Marks, Windows
@section Customizing Window Appearance

@defvar *maxsize-border-width*
The width in pixels given to the borders of windows with maxsize or ratio hints.
@end defvar

@defvar *transient-border-width*
The width in pixels given to the borders of transient or pop-up windows.
@end defvar

@defvar *normal-border-width*
The width in pixels given to the borders of regular windows.
@end defvar

@defvar *window-border-style*
This controls the appearance of the border around windows. valid
values are:
@table @var
@item :thick
All space within the frame not used by the window is dedicated to the
border.

@item :thin
Only the border width as controlled by *maxsize-border-width*
*normal-border-width* and *transient-border-width* is used as the
border. The rest is filled with the unfocus color.

@item :tight
The same as :thin but the border surrounds the window and the wasted
space within the frame is not obscured, revealing the background.

@item :none
Like :tight but no border is ever visible.
@end table

After changing this variable you may need to call
sync-all-frame-windows to see the change.
@end defvar


@defun {set-win-bg-color} color
Set the background color of the window. The background color will only
be visible for windows with size increment hints such as @samp{emacs}
and @samp{xterm}.
@end defun

@defun {set-focus-color} color
Set the border color for focused windows. This is only used when
there is more than one frame.
@end defun

@defun {set-unfocus-color} color
Set the border color for windows without focus. This is only used when
there is more than one frame.
@end defun

@defun {set-normal-gravity} gravity
Set the default gravity for normal windows. Possible values are
@code{:center} @code{:top} @code{:left} @code{:right} @code{:bottom}
@code{:top-left} @code{:top-right} @code{:bottom-left} and
@code{:bottom-right}.
@end defun

@defun {set-maxsize-gravity} gravity
Set the default gravity for maxsize windows.
@end defun

@defun {set-transient-gravity} gravity
Set the default gravity for transient/pop-up windows.
@end defun


@deffn {Command} gravity gravity
Set a window's gravity within its frame. Gravity controls where the
window will appear in a frame if it is smaller that the
frame. Possible values are:

@table @var
@item center
@item top
@item right
@item bottom
@item left
@item top-right
@item top-left
@item bottom-right
@item bottom-left
@end table
@end deffn


@node Controlling Raise And Map Requests, Programming With Windows, Customizing Window Appearance, Windows
@section Controlling Raise And Map Requests
It is sometimes handy to deny a window's request to be focused. The
following variables determine such behavior.

A map request occurs when a new or withdrawn window requests to be
mapped for the first time.

A raise request occurs when a client asks the window manager to give
an existing window focus.

@defvar *deny-map-request*
A list of window properties that dswm should deny matching windows'
requests to become mapped for the first time.
@end defvar

@defvar *deny-raise-request*
Exactly the same as @var{*deny-map-request*} but for raise requests.

Note that no denial message is displayed if the window is already visible.
@end defvar

@defvar *suppress-deny-messages*
For complete focus on the task at hand, set this to @code{T} and no
raise/map denial messages will be seen.
@end defvar


Some examples follow.

@example
;; Deny the firefox window from taking focus when clicked upon.
(push '(:class "gecko") dswm:*deny-raise-request*)

;; Deny all map requests
(setf dswm:*deny-map-request* t)

;; Deny transient raise requests
(push '(:transient) dswm:*deny-map-request*)

;; Deny the all windows in the xterm class from taking focus.
(push '(:class "Xterm") dswm:*deny-raise-request*)
@end example

@node Programming With Windows, Rule Based Window Placement, Controlling Raise And Map Requests, Windows
@section Programming With Windows

@defmac {define-window-slot} attr
Create a new window attribute and corresponding get/set functions.
@end defmac


@defun {window-send-string} string &optional (window (current-window))
Send the string of characters to the current window as if they'd been typed.
@end defun

@defvar *default-window-name*
The name given to a window that does not supply its own name.
@end defvar


@node Rule Based Window Placement, Remember-Forget-Recall Subsystem, Programming With Windows, Windows
@section Rule Based Window Placement

@defmac {define-frame-preference} target-group &rest frame-rules
Create a rule that matches windows and automatically places them in
a specified group and frame. Each frame rule is a lambda list:
@example
(frame-number raise lock &key create restore dump-name class instance type role title)
@end example

@table @var
@item frame-number
The frame number to send matching windows to

@item raise
When non-nil, raise and focus the window in its frame

@item lock
When this is nil, this rule will only match when the current group
matches @var{target-group}. When non-nil, this rule matches regardless
of the group and the window is sent to @var{target-group}. If
@var{lock} and @var{raise} are both non-nil, then dswm will jump to
the specified group and focus the matched window.

@item create
When non-NIL the group is created and eventually restored when the value of
create is a group dump filename in *DATA-DIR*. Defaults to NIL.

@item restore
When non-NIL the group is restored even if it already exists. This arg should
be set to the dump filename to use for forced restore. Defaults to NIL

@item class
The window's class must match @var{class}.

@item instance
The window's instance/resource name must match @var{instance}.

@item type
The window's type must match @var{type}.

@item role
The window's role must match @var{role}.

@item title
The window's title must match @var{title}.
@end table
@end defmac


@node Remember-Forget-Recall Subsystem, , Rule Based Window Placement, Windows
@section Remember-Forget-Recall Subsystem

@deffn {Command} remember what
Remember rules for some desktop element, like frames placement on group,
 group placement on screen, or window-placement
@end deffn

@deffn {Command} forget what
Forget remembered rules for some desktop element, like frames
placement on group, group placement on screen, or window-placement
@end deffn

@deffn {Command} recall what
Recall remembered rules for some desktop element, like frames
placement on group, group placement on screen, or window-placement
@end deffn


@defun {remember-group} &key (group (current-group)) permanent-p
nil
@end defun

@defun {remember-screen} &key (screen (current-screen)) permanent-p
nil
@end defun

@defun {remember-desktop} &key permanent-p
nil
@end defun

@defun {remember-window-placement} &key (window (current-window)) (lock-p t) title-p permanent-p
nil
@end defun

@defun {remember-group-windows-placement} &key (group (current-group)) (lock-p t) (title-p nil) (permanent-p nil)
Guess at a placement rule for all WINDOWS in group and add it to the current set.
@end defun

@defun {remember-screen-windows-placement} &key (screen (current-screen)) (lock-p t) title-p permanent-p
Guess at a placement rule for all WINDOWS in all groups in current screen and add it to the current set.
@end defun

@defun {remember-all-window-placement} &key (lock-p t) title-p permanent-p
nil
@end defun

@defun {remember-all} &key (lock-p t) title-p permanent-p
Make rules of all existing windows, bind it to groups and frames,
where they located now and dump all groups frames and window placement
rules to frame-froup-placement.rules and window-placement.rules in
data dir
@end defun

@defun {forget-group} &key (group (current-group)) permanent-p
nil
@end defun

@defun {forget-screen} &key (screen (current-screen)) permanent-p
nil
@end defun

@defun {forget-desktop} &key permanent-p
nil
@end defun

@defun {forget-window-placement} &key (window (current-window)) permanent-p
Forget window of given group and screen
@end defun

@defun {forget-group-windows-placement} &key (group (current-group)) permanent-p
Forget all windows of given group
@end defun

@defun {forget-screen-windows-placement} &key (screen (current-screen)) permanent-p
Forget all windows of given screen
@end defun

@defun {forget-all-window-placement} &key permanent-p
Remove all window-placement rules
@end defun

@defun {forget-all} &key permanent-p
Remove all placement rules and rule files
@end defun

@defun {recall-group} &key (group (current-group)) permanent-p
nil
@end defun

@defun {recall-screen} &key (screen (current-screen)) permanent-p
nil
@end defun

@defun {recall-desktop} &key permanent-p
nil
@end defun

@defun {recall-window-placement} &key (window (current-window)) (permanent-p nil)
nil
@end defun

@defun {recall-group-windows-placement} &key (group (current-group)) (permanent-p nil)
nil
@end defun

@defun {recall-screen-windows-placement} &key (screen (current-screen)) (permanent-p nil)
nil
@end defun

@defun {recall-all-window-placement} &key permanent-p
nil
@end defun

@defun {recall-all} 
Recall frame and group and windows placement rules of all groups and frames
@end defun


@node Frames, Mode-line, Windows, Top
@chapter Frames
Frames contain windows. All windows exist within a frame.

Those used to ratpoison will notice that this differs from ratpoison's
window pool, where windows and frames are not so tightly connected.

@deffn {Command} pull-window-by-number n &optional (group (current-group))
Pull window N from another frame into the current frame and focus it.
@end deffn

@deffn {Command} hsplit &optional (ratio 1/2)
Split the current frame into 2 side-by-side frames.
@end deffn

@deffn {Command} vsplit &optional (ratio 1/2)
Split the current frame into 2 frames, one on top of the other.
@end deffn

@deffn {Command} remove-split &optional (group (current-group)) (frame
                                                                 (tile-group-current-frame
                                                                  group))
Remove the specified frame in the specified group (defaults to current
group, current frame). Windows in the frame are migrated to the frame taking up its
space.
@end deffn

@deffn {Command} only 
Delete all the frames but the current one and grow it to take up the entire head.
@end deffn

@deffn {Command} curframe 
Display a window indicating which frame is focused.
@end deffn

@deffn {Command} fnext 
Cycle through the frame tree to the next frame.
@end deffn

@deffn {Command} sibling 
Jump to the frame's sibling. If a frame is split into two frames,
these two frames are siblings.
@end deffn

@deffn {Command} fother 
Jump to the last frame that had focus.
@end deffn

@deffn {Command} fselect frame-number
Display a number in the corner of each frame and let the user to
select a frame by number. If @var{frame-number} is specified, just
jump to that frame.
@end deffn

@deffn {Command} resize width height
Resize the current frame by @var{width} and @var{height} pixels
@end deffn

@deffn {Command} balance-frames 
Make frames the same height or width in the current frame's subtree.
@end deffn

@deffn {Command} fclear 
Clear the current frame.
@end deffn

@deffn {Command} move-focus dir
Focus the frame adjacent to the current one in the specified
direction. The following are valid directions:
@table @asis
@item up
@item down
@item left
@item right
@end table
@end deffn

@deffn {Command} move-window dir
Just like move-focus except that the current is pulled along.
@end deffn

@deffn {Command} next-in-frame 
Go to the next window in the current frame.
@end deffn

@deffn {Command} prev-in-frame 
Go to the previous window in the current frame.
@end deffn

@deffn {Command} other-in-frame 
Go to the last accessed window in the current frame.
@end deffn

@deffn {Command} echo-frame-windows &optional (fmt *window-format*)
Display a list of all the windows in the current frame.
@end deffn

@deffn {Command} exchange-direction dir &optional (win (current-window))
Exchange the current window (by default) with the top window of the frame in specified direction.
@table @asis
@item up
@item down
@item left
@item right
@end table
@end deffn


@defvar *min-frame-width*
The minimum width a frame can be. A frame will not shrink below this
width. Splitting will not affect frames if the new frame widths are
less than this value.
@end defvar

@defvar *min-frame-height*
The minimum height a frame can be. A frame will not shrink below this
height. Splitting will not affect frames if the new frame heights are
less than this value.
@end defvar

@defvar *new-frame-action*
When a new frame is created, this variable controls what is put in the
new frame. Valid values are

@table @code
@item :empty
The frame is left empty

@item :last-window
The last focused window that is not currently visible is placed in the
frame. This is the default.
@end table
@end defvar


@menu
* Interactively Resizing Frames::  
* Frame Dumping::               
@end menu

@node Interactively Resizing Frames, Frame Dumping, Frames, Frames
@section Interactively Resizing Frames
There is a mode called @code{iresize} that lets you interactively
resize the current frame. To enter the mode use the @code{iresize}
command or type @key{PREF r}.

The following keybindings apply to the mode:
@table @kbd
@item C-p
@itemx Up
@itemx k
Shrink the frame vertically.

@item C-n
@itemx Down
@itemx j
Expand the frame vertically.

@item C-f
@itemx Right
@itemx l
Expand the frame horizontally.

@item C-b
@itemx Left
@itemx h
Shrink the frame horizontally.

@item C-g
@itemx ESC
Abort the interactive resize. NOTE: This currently doesn't work.

@item RET
Select the highlighted option.

@end table

@deffn {Command} iresize 
Start the interactive resize mode. A new keymap specific to
resizing the current frame is loaded. Hit @key{C-g}, @key{RET}, or
@key{ESC} to exit.
@end deffn

@deffn {Command} abort-iresize 
Exit from the interactive resize mode.
@end deffn

@deffn {Command} exit-iresize 
Exit from the interactive resize mode.
@end deffn


@defvar *resize-increment*
Number of pixels to increment by when interactively resizing frames.
@end defvar


@node Frame Dumping,  , Interactively Resizing Frames, Frames
@section Frame Dumping
The configuration of frames and groups can be saved and restored using
the following commands.

@deffn {Command} dump-desktop-to-file file
Dumps the frames of all groups of all screens to the named file
@end deffn

@deffn {Command} dump-group-to-file file
Dumps the frames of the current group of the current screen to the named file.
@end deffn

@deffn {Command} dump-screen-to-file file
Dumps the frames of all groups of the current screen to the named file
@end deffn

@deffn {Command} restore-from-file file
Restores screen, groups, or frames from named file, depending on file's contents.
@end deffn

@deffn {Command} place-existing-windows 
Re-arrange existing windows according to placement rules.
@end deffn


@node Mode-line, Groups, Frames, Top
@chapter The Mode Line
The mode line is a bar that runs across either the top or bottom of
a head and is used to display information. By default the mode line
displays the list of windows, similar to the output @kbd{PREF w} produces.

Alternatively, external panel applications such as the GNOME panel and
KDE's kicker may be used. Simply starting one of these programs is enough
to set it as the mode line of the head it would like to be on (if the
panel is Xinerama aware) or whichever head is available. In order to
avoid problems displaying menus, configure your panel application for
positioning at the top or bottom of the head rather than relying on
@var{*mode-line-position*}

The mode line can be turned on and off with the @command{mode-line}
command or the lisp function @code{dswm:toggle-mode-line}. Each
head has its own mode line. For example:

@example
;; turn on/off the mode line for the current head only.
(dswm:toggle-mode-line (dswm:current-screen)
                          (dswm:current-head))
@end example

The mode line is updated after every DSWM command.

To display the window list and the current date on the modeline, one
might do the following:

@example
(setf dswm:*screen-mode-line-format*
      (list "%w | "
            '(:eval (dswm:run-shell-command "date" t))))
@end example

@code{(dswm:run-shell-command "date" t)} runs the command
@command{date} and returns its output as a string.

@deffn {Command} mode-line 
A command to toggle the mode line visibility.
@end deffn


@defun {toggle-mode-line} screen head &optional (format (screen-mode-line-format))
Toggle the state of the mode line for the specified screen
@end defun


@defvar *screen-mode-line-format*
nil
@end defvar


The following variables control the color, position, and size of the
mode line.

@defvar *mode-line-position*
Specifies where the mode line is displayed. Valid values are :top and :bottom.
@end defvar

@defvar *mode-line-border-width* 1
nil
@end defvar

@defvar *mode-line-pad-x* 
nil
@end defvar

@defvar *mode-line-pad-y* 
nil
@end defvar

@defvar *mode-line-background-color* 
nil
@end defvar

@defvar *mode-line-foreground-color* 
nil
@end defvar

@defvar *mode-line-border-color* 
nil
@end defvar

@defvar *mode-line-timeout*
The modeline updates after each command, when a new window appears or
an existing one disappears, and on a timer. This variable controls how
many seconds elapse between each update. If this variable is changed
while the modeline is visible, you must toggle the modeline to update
timer.
@end defvar


@node Groups, Screens, Mode-line, Top
@chapter Groups
Groups in DSWM are more commonly known as @dfn{virtual desktops} or
@dfn{workspaces}. Why not create a new term for it?

@deffn {Command} gnew name
Create a new group with the specified name. The new group becomes the
current group. If @var{name} begins with a dot (``.'') the group new
group will be created in the hidden state. Hidden groups have group
numbers less than one and are invisible to from gprev, gnext, and, optionally,
groups and vgroups commands.
@end deffn

@deffn {Command} gnew-float name
Create a floating window group with the specified name and switch to it.
@end deffn

@deffn {Command} gnewbg name
Create a new group but do not switch to it.
@end deffn

@deffn {Command} gnewbg-float name
Create a floating window group with the specified name, but do not switch to it.
@end deffn

@deffn {Command} gnext 
Cycle to the next group in the group list.
@end deffn

@deffn {Command} gprev 
Cycle to the previous group in the group list.
@end deffn

@deffn {Command} gnext-with-window 
Cycle to the next group in the group list, taking the current
window along.
@end deffn

@deffn {Command} gprev-with-window 
Cycle to the previous group in the group list, taking the current
window along.
@end deffn

@deffn {Command} gother 
Go back to the last group.
@end deffn

@deffn {Command} gmerge from
Merge @var{from} into the current group. @var{from} is not deleted.
@end deffn

@deffn {Command} vgroups &optional gfmt wfmt
Like @command{groups} but also display the windows in each group. The
optional arguments @var{gfmt} and @var{wfmt} can be used to override
the default group formatting and window formatting, respectively.
@end deffn

@deffn {Command} gselect to-group
Select the first group that starts with
@var{substring}. @var{substring} can also be a number, in which case
@command{gselect} selects the group with that number.
@end deffn

@deffn {Command} gmove group
Move the current window to the specified group.
@end deffn

@deffn {Command} gkill 
Kill the current group. All windows in the current group are migrated
to the next group.
@end deffn

@deffn {Command} grename name
Rename the current group.
@end deffn

@deffn {Command} grouplist &optional (fmt *group-format*)
Allow the user to select a group from a list, like windowlist but
  for groups
@end deffn

@deffn {Command} grun command group
Run shell command in specified group
@end deffn

@deffn {Command} grun-new command
Run shell command in new tile group with same name with command
@end deffn

@deffn {Command} grun-new-float command
Run shell command in new float group with same name with command
@end deffn

@menu
* Customizing Groups::          
@end menu

@node Customizing Groups,  , Groups, Groups
@section Customizing Groups

@defvar *group-formatters*
An alist of characters and formatter functions. The character can be
used as a format character in @var{*group-format*}. When the character
is encountered in the string, the corresponding function is called
with a group as an argument. The functions return value is inserted
into the string. If the return value isn't a string it is converted to
one using @code{prin1-to-string}.
@end defvar

@defvar *group-format*
The format string that decides what information will show up in the
group listing. The following format options are available:

@table @asis
@item %n
The group's number.

@item %s
The group's status. Similar to a window's status.

@item %t
The group's name.
@end table
@end defvar


@defun {current-group} &optional (screen (current-screen))
Return the current group for the current screen, unless
otherwise specified.
@end defun


@node Screens, Interacting With Unix, Groups, Top
@chapter Screens
DSWM handles multiple screens.

@deffn {Command} snext 
Go to the next screen.
@end deffn

@deffn {Command} sprev 
Go to the previous screen.
@end deffn

@deffn {Command} sother 
Go to the last screen.
@end deffn


@menu
* Xinerama::                    
* Programming With Screens::    
@end menu

@node Xinerama, Programming With Screens, Screens, Screens
@section Xinerama
DSWM will attempt to detect Xinerama heads at startup (and at no other
time.) Heads are logically contained by screens. In a dual-monitor Xinerama
configuration, there will be one screen with two heads. Non-rectangular layouts
are supported (frames will not be created in the 'dead zone'.) And message
windows will be displayed on the current head--that is, the head to which the
currently focused frame belongs.

@node Programming With Screens,  , Xinerama, Screens
@section Programming With Screens

@defun {current-screen} 
Return the current screen.
@end defun


@defun {screen-current-window} screen
Return the current window on the specified screen
@end defun


@defun {current-window} 
Return the current window on the current screen
@end defun


@defvar *screen-list*
The list of screens managed by dswm.
@end defvar

        
@node Interacting With Unix, Interacting With X11, Screens, Top
@chapter Interacting With Unix

@deffn {Command} run-shell-command cmd &optional collect-output-p
Run the specified shell command. If @var{collect-output-p} is @code{T}
then run the command synchonously and collect the output. Be
careful. If the shell command doesn't return, it will hang DSWM. In
such a case, kill the shell command to resume DSWM.
@end deffn


@defun {programs-in-path} &optional full-path (path (split-string (getenv PATH) :))
Return a list of programs in the path. if @var{full-path} is
@var{t} then return the full path, otherwise just return the
filename. @var{path} is by default the @env{PATH} evironment variable
but can be specified. It should be a string containing each directory
seperated by a colon.
@end defun

@defun {pathname-is-executable-p} pathname
Return T if the pathname describes an executable file.
@end defun


@defvar *shell-program*
The shell program used by @code{run-shell-command}.
@end defvar


@defun {getenv} var
Get values of UNIX system environment variables
@end defun

@defun {(setf getenv)} val var
Set the value of the environment variable, @var{var} to @var{val}.
@end defun


@node Interacting With X11, Miscellaneous Commands, Interacting With Unix, Top
@chapter Interacting With X11

@defun {set-x-selection} text
Set the X11 selection string to @var{string}.
@end defun

@defun {get-x-selection} &optional timeout
Return the x selection no matter what client own it.
@end defun


@node Miscellaneous Commands, Colors, Interacting With X11, Top
@chapter Miscellaneous Commands
The following is a list of commands that don't really fit in any other
section.

@deffn {Command} editor 
Start default DSWM editor unless it is already running, in which case focus it.
@end deffn

@deffn {Command} banish &optional where
Warp the mouse the lower right corner of the current head.
@end deffn

@deffn {Command} ratwarp x y
Warp the mouse to the specified location.
@end deffn

@deffn {Command} ratrelwarp dx dy
Warp the mouse by the specified amount from its current position.
@end deffn

@deffn {Command} ratclick &optional (button 1)
Simulate a pointer button event at the current pointer
location. Note: this function is unlikely to work unless
your X server and CLX implementation support XTEST.
@end deffn

@deffn {Command} echo-date 
Display the date and time.
@end deffn

@deffn {Command} eval-line cmd
Evaluate the s-expression and display the result(s).
@end deffn

@deffn {Command} window-send-string string &optional (window (current-window))
Send the string of characters to the current window as if they'd been typed.
@end deffn

@deffn {Command} reload 
Reload DSWM using @code{asdf}.
@end deffn

@deffn {Command} loadrc 
Reload the @file{~/.dswm} file.
@end deffn

@deffn {Command} keyboard-quit 
@end deffn

@deffn {Command} quit 
Quit DSWM.
@end deffn

@deffn {Command} restart-hard 
Restart dswm. This is handy if a new dswm executable has been
made and you wish to replace the existing process with it.

Any run-time customizations will be lost after the restart.
@end deffn

@deffn {Command} restart-soft 
Soft Restart DSWM. The lisp process isn't restarted. Instead,
control jumps to the very beginning of the dswm program. This
differs from RESTART, which restarts the unix process.

Since the process isn't restarted, existing customizations remain
after the restart.
@end deffn

@deffn {Command} getsel 
Echo the X selection.
@end deffn

@deffn {Command} putsel string
Stuff the string @var{string} into the X selection.
@end deffn

@deffn {Command} command-mode 
Command mode allows you to type ratpoison commands without needing the
@key{C-j} prefix. Keys not bound in StumpWM will still get sent to the
current window. To exit command mode, type @key{C-g}.
@end deffn

@deffn {Command} copy-unhandled-error 
When an unhandled error occurs, DSWM restarts and attempts to
continue. Unhandled errors should be reported to the mailing list so
they can be fixed. Use this command to copy the unhandled error and
backtrace to the X11 selection so you can paste in your email when
submitting the bug report.
@end deffn

@deffn {Command} commands 
List all available commands.
@end deffn

@deffn {Command} lastmsg 
Display the last message. If the previous command was lastmsg, then
continue cycling back through the message history.
@end deffn

@deffn {Command} window-full-info 
List all the properties of the current window and their values,
like xprop.
@end deffn


@defun {run-commands} &rest commands
Run each dswm command in sequence. This could be used if you're
used to ratpoison's rc file and you just want to run commands or don't
know lisp very well. One might put the following in one's rc file:

@example
(dswm:run-commands
  "escape C-z"
  "exec firefox"
  "split")
@end example
@end defun


@defmac {defcommand} name (&rest args) (&rest interactive-args) &body body
Create a command function and store its interactive hints in
*command-hash*. The local variable %interactivep% can be used to check
if the command was called interactively. If it is non-NIL then it was
called from a keybinding or from the colon command.

INTERACTIVE-ARGS is a list of the following form: ((TYPE PROMPT) (TYPE PROMPT) ...)

each element in INTERACTIVE-ARGS declares the type and prompt for the
command's arguments.

TYPE can be one of the following:

@table @var
@item :y-or-n
A yes or no question returning T or NIL.
@item :variable
A lisp variable
@item :function
A lisp function
@item :command
A dswm command as a string.
@item :key-seq
A key sequence starting from *TOP-MAP*
@item :window-number
An existing window number
@item :number
An integer number
@item :string
A string
@item :key
A single key chord
@item :window-name
An existing window's name
@item :direction
A direction symbol. One of :UP :DOWN :LEFT :RIGHT
@item :gravity
A gravity symbol. One of :center :top :right :bottom :left :top-right :top-left :bottom-right :bottom-left
@item :group
An existing group
@item :frame
A frame
@item :shell
A shell command
@item :rest
The rest of the input yes to be parsed.
@item :module
An existing dswm module
@end table

Note that new argument types can be created with DEFINE-DSWM-TYPE.

PROMPT can be string. In this case, if the corresponding argument is
missing from an interactive call, dswm will use prompt for its
value using PROMPT. If PROMPT is missing or nil, then the argument is
considered an optional interactive argument and is not prompted for
when missing.

Alternatively, instead of specifying nil for PROMPT or leaving it
out, an element can just be the argument type.
@end defmac

@defmac {define-dswm-type} type (input prompt &key completion-builder) &body body
Create a new type that can be used for command arguments. @var{type} can be any symbol.

When @var{body} is evaluated @var{input} is bound to the
argument-line. It is passed to @code{argument-pop},
@code{argument-pop-rest}, etc. @var{prompt} is the prompt that should
be used when prompting the user for the argument.

@example
(define-dswm-type :symbol (input prompt)
 (or (find-symbol (string-upcase
		     (or (argument-pop input)
                         ;; Whitespace messes up find-symbol.
		         (string-trim " "
		           (completing-read (current-screen)
					  prompt
					  ;; find all symbols in the
					  ;;  dswm package.
					  (let (acc)
					    (do-symbols (s (find-package "DSWM"))
					      (push (string-downcase (symbol-name s)) acc))
					    acc)))
                      (throw 'error "Abort.")))
                  "DSWM")
     (throw 'error "Symbol not in DSWM package")))

(defcommand "symbol" (sym) ((:symbol "Pick a symbol: "))
  (message "~a" (with-output-to-string (s)
	          (describe sym s))))
@end example

This code creates a new type called @code{:symbol} which finds the
symbol in the dswm package. The command @code{symbol} uses it and
then describes the symbol.
@end defmac


@defun {run-or-raise} cmd props &optional (all-groups *run-or-raise-all-groups*) (all-screens *run-or-raise-all-screens*)
Run the shell command, @var{cmd}, unless an existing window
matches @var{props}. @var{props} is a property list with the following keys:

@table @code
@item :class
Match the window's class.
@item :instance
Match the window's instance or resource-name.
@item :role
Match the window's @code{WM_WINDOW_ROLE}.
@item :title
Match the window's title.
@end table

By default, the global @var{*run-or-raise-all-groups*} decides whether
to search all groups or the current one for a running
instance. @var{all-groups} overrides this default. Similarily for
@var{*run-or-raise-all-screens*} and @var{all-screens}.
@end defun


@defvar *run-or-raise-all-groups*
When this is @code{T} the @code{run-or-raise} function searches all groups for a
running instance. Set it to NIL to search only the current group.
@end defvar

@defvar *run-or-raise-all-screens*
When this is @code{T} the @code{run-or-raise} function searches all screens for a
running instance. Set it to @code{NIL} to search only the current screen. If
@var{*run-or-raise-all-groups*} is @code{NIL} this variable has no effect.
@end defvar


@defun {restarts-menu} err
Display a menu with the active restarts and let the user pick
one. Error is the error being recovered from. If the user aborts the
menu, the error is re-signalled.
@end defun


@defmac {with-restarts-menu} &body body
Execute BODY. If an error occurs allow the user to pick a
restart from a menu of possible restarts. If a restart is not
chosen, resignal the error.
@end defmac


@defvar *suppress-abort-messages*
Suppress abort message when non-nil.
@end defvar

@defvar *default-package*
This is the package eval reads and executes in. You might want to set
this to @code{:dswm} if you find yourself using a lot of internal
dswm symbols. Setting this variable anywhere but in your rc file
will have no effect.
@end defvar


@defmac {defprogram-shortcut} name &key (command (string-downcase (string name))) (props (quasiquote (quote (class #S(sb-impl::comma :expr (string-capitalize command) :kind 0))))) (map *top-map*) (key (kbd (concat H- (subseq command 0 1)))) (pullp nil) (pull-name (intern1 (concat (string name) -PULL))) (pull-key (kbd (concat H-M- (subseq command 0 1))))
Define a command and key binding to run or raise a program. If
@var{pullp} is set, also define a command and key binding to run or
pull the program.
@end defmac


@defvar *initializing*
True when starting dswm. Use this variable in your rc file to
run code that should only be executed once, when dswm starts up and
loads the rc file.
@end defvar


@menu
* Menus::                       
* DSWM's Data Directory::    
* Debugging DSWM::           
* Timers::                      
* Getting Help::                
@end menu

@node Menus, DSWM's Data Directory, Miscellaneous Commands, Miscellaneous Commands
@section Menus
Some commands present the options in a menu. The following are the menu key bindings:

@table @kbd
@item C-p
@itemx Up
@itemx k
Highlight the previous menu option.

@item C-n
@itemx Down
@itemx j
Highlight the next menu option.

@item C-g
@itemx ESC
Abort the menu.

@item RET
Select the highlighted option.

@end table

@node DSWM's Data Directory, Debugging DSWM, Menus, Miscellaneous Commands
@section DSWM's Directories
DSWM uses freedesktop recommendations for directories locations. So,
your config and data directories by default are:

@table @file
@item System configuration file
1. System environment variable @var{$XDG_CONFIG_DIR}
2. If it is not set, than @file{/etc/xdg/dswm/dswm.lisp}

@item User configuration file
1. @file{~/.dswm}
2. If it does not exists, than path, which set in system environment
variable @var{$XDG_CONFIG_HOME/dswm/init.lisp}
3. If it does not exists too, than @file{~/.config/dswm/init.lisp}

@item System data directory
1. System environment variable @var{$XDG_DATA_DIR}
2. If it does not exists, than @file{/usr/local/share/dswm/} (or
<where_your_share_prefix>/dswm/)

@item User data directory
1. System environment variable @var{$XDG_DATA_HOME/dswm/}
2. If it does not exists, than @file{~/.local/share/dswm/}

@end table

If you want to store DSWM data between sessions, the recommended
method is to store them in DSWM data directory. DSWM supplies
some functions to make doing this easier.

@defun {data-dir} &optional subdir
nil
@end defun

@defun {data-dir-file} name &optional type subdir
Return a pathname inside dswm's data dir with the specified name and type
@end defun

@defmac {with-data-file} (s file &rest keys &key (if-exists supersede) &allow-other-keys) type subdir &body body
Open a file in DSWM's data directory. keyword arguments are sent
directly to OPEN. Note that IF-EXISTS defaults to :supersede, instead
of :error.
@end defmac


@node Debugging DSWM, Timers, DSWM's Data Directory, Miscellaneous Commands
@section Debugging DSWM

@defvar *debug-level*
Set this variable to a number > 0 to turn on debugging. The greater the number the more debugging output.
@end defvar

@defvar *debug-stream*
This is the stream debugging output is sent to. It defaults to
*error-output*. It may be more convenient for you to pipe debugging
output directly to a file.
@end defvar

@defun {redirect-all-output} file
Elect to redirect all output to the specified file. For instance,
if you want everything to go to ~/dswm.d/debug-output.txt you would
do:

@example
 (redirect-all-output (data-dir-file "debug-output" "txt"))
@end example
@end defun


@node Timers, Getting Help, Debugging DSWM, Miscellaneous Commands
@section Timers
DSWM has a timer system similar to that of @dfn{Emacs}.

@defun {run-with-timer} secs repeat function &rest args
Perform an action after a delay of SECS seconds.
Repeat the action every REPEAT seconds, if repeat is non-nil.
SECS and REPEAT may be reals.
The action is to call FUNCTION with arguments ARGS.
@end defun

@defun {cancel-timer} timer
Remove TIMER from the list of active timers.
@end defun


@defun timer-p @var{timer}
Return T if TIMER is a timer structure.
@end defun

@node Getting Help,  , Timers, Miscellaneous Commands
@section Getting Help

@deffn {Command} describe-key keys
Either interactively type the key sequence or supply it as text. This
command prints the command bound to the specified key sequence.
@end deffn

@deffn {Command} describe-variable var
Print the online help associated with the specified variable.
@end deffn

@deffn {Command} describe-function fn
Print the online help associated with the specified function.
@end deffn

@deffn {Command} where-is cmd
Print the key sequences bound to the specified command.
@end deffn

@deffn {Command} modifiers 
List the modifiers dswm recognizes and what MOD-X it thinks they're on.
@end deffn


@node Colors, Hooks, Miscellaneous Commands, Top
@chapter Colors
All text printed by dswm is run through a coloring engine before
being displayed. All color commands start with a @samp{^} (caret)
character and apply to all text after it.

@table @code
@item ^0-9
A caret followed by a single digit number changes the foreground color
to the specified color. A @samp{*} can be used to specify the normal
color. See the color listing below.

@item ^0-90-9
A caret followed by two digits sets the foreground and background
color. The first digit refers to the foreground color and the second
digit to the background color. A @samp{*} can be used in place of
either digit to specify the normal color. See the color listing below.

@item ^B
Turn on bright colors.

@item ^b
Turn off bright colors.

@item ^n
Use the normal background and foreground color.

@item ^R
Reverse the foreground and background colors.

@item ^r
Turn off reverse colors.

@item ^[
Push the current colors onto the color stack. The current colors remain unchanged.

@item ^]
Pop the colors off the color stack.

@item ^^
Print a regular caret.
@end table

The default colors are made to resemble the 16 VGA colors and are:
@table @asis
@item 0 black
@item 1 red
@item 2 green
@item 3 yellow
@item 4 blue
@item 5 magenta
@item 6 cyan
@item 7 white
@end table

There are only 8 colors by default but 10 available digits. The last
two digits are left up to the user. @ref{Behind The Scenes Look At
Colors} for information on customizing colors.

@menu
* Behind The Scenes Look At Colors::  
@end menu

@node Behind The Scenes Look At Colors,  , Colors, Colors
@section Behind The Scenes Look At Colors

Color indexes are stored in @var{*colors*} as a list. The default list
of colors leave 2 slots for the user to choose. If you'd like to use
@samp{Papaya Whip} and @samp{Dark Golden Rod 3} you might eval the
following:

@example
(setf *colors* (append *colors*
                       (list "PapayaWhip"
                             "DarkGoldenRod3")))
(update-color-map (current-screen))
@end example

Of course, you can change all the colors if you like.

@defun {parse-color-string} string
parse a color coded string into a list of strings and color codes
@end defun

@defun {uncolorify} string
Remove any color markup in STRING
@end defun

@defvar *colors*
Eight colors by default. You can redefine these to whatever you like and
then call (update-color-map).
@end defvar

@defun {update-color-map} screen
Read *colors* and cache their pixel colors for use when rendering colored text.
@end defun


@node Hooks, Modules, Colors, Top
@chapter Hooks
DSWM exports a number of hooks you can use to add customizations;
like hooks in Emacs, you add to a hook with the @code{add-hook}
function. for example:

@example
(dswm:add-hook 'dswm:*new-window-hook* 'my-new-window-custos)
@end example

adds your @code{my-new-window-custos} function to the list of
functions called when a new window appears.

@defmac {add-hook} hook fn
Add @var{function} to the hook @var{hook-variable}. For example, to
display a message whenever you switch frames:

@example
(defun my-rad-fn (to-frame from-frame)
  (dswm:message "Mustard!"))

(dswm:add-hook dswm:*focus-frame-hook* 'my-rad-fn)
@end example
@end defmac

@defmac {remove-hook} hook fn
Remove the specified function from the hook.
@end defmac


The following hooks are available:

@defvr {Hook} *new-window-hook*
A hook called whenever a window is added to the window list. This
includes a genuinely new window as well as bringing a withdrawn window
back into the window list.
@end defvr

@defvr {Hook} *destroy-window-hook*
A hook called whenever a window is destroyed or withdrawn.
@end defvr

@defvr {Hook} *focus-window-hook*
A hook called when a window is given focus. It is called with 2
arguments: the current window and the last window (could be nil).
@end defvr

@defvr {Hook} *place-window-hook*
A hook called whenever a window is placed by rule. Arguments are
window group and frame
@end defvr

@defvr {Hook} *start-hook*
A hook called when dswm starts.
@end defvr

@defvr {Hook} *internal-loop-hook*
A hook called inside dswm's inner loop.
@end defvr

@defvr {Hook} *focus-frame-hook*
A hook called when a frame is given focus. The hook functions are
called with 2 arguments: the current frame and the last frame.
@end defvr

@defvr {Hook} *new-frame-hook*
A hook called when a new frame is created. the hook is called with
the frame as an argument.
@end defvr

@defvr {Hook} *message-hook*
A hook called whenever dswm displays a message. The hook
function is passed any number of arguments. Each argument is a
line of text.
@end defvr

@defvr {Hook} *top-level-error-hook*
Called when a top level error occurs. Note that this hook is
run before the error is dealt with according to
*top-level-error-action*.
@end defvr

@defvr {Hook} *focus-group-hook*
A hook called whenever dswm switches groups. It is called with 2 arguments: the current group and the last group.
@end defvr

@defvr {Hook} *key-press-hook*
A hook called whenever a key under *top-map* is pressed.
It is called with 3 argument: the key, the (possibly incomplete) key
sequence it is a part of, and command value bound to the key.
@end defvr

@defvr {Hook} *root-click-hook*
A hook called whenever there is a mouse click on the root
window. Called with 4 arguments, the screen containing the root
window, the button clicked, and the x and y of the pointer.
@end defvr

@defvr {Hook} *mode-line-click-hook*
Called whenever the mode-line is clicked. It is called with 4 arguments,
the mode-line, the button clicked, and the x and y of the pointer.
@end defvr

@defvr {Hook} *urgent-window-hook*
A hook called whenever a window sets the property indicating that
  it demands the user's attention
@end defvr

@defvr {Hook} *event-processing-hook*
A hook, called, when any event occurs
@end defvr


@node Modules, Hacking, Hooks, Top
@chapter Modules
DSWM has a growing number of modules not loaded by default. All
modules exist in the @file{modules/} subdirectory of DSWM's data
directories.

@deffn {Command} load-module name &optional force-p
Loads the contributed module with the given NAME.
@end deffn


@node Hacking, Command and Function Index, Modules, Top
@chapter Hacking

For those of you who have worked on Free Software projects before,
this part should probably be fairly intuitive.

@menu
* General Advice::              
* Using git with DSWM::      
* Sending Patches::             
@end menu

@node General Advice, Using git with DSWM, Hacking, Hacking
@section Hacking:  General Advice

@enumerate

@item
Pay attention to file names and contents. If you're making changes to
mode-line related code, don't put it in @file{core.lisp}. If you're
introducing some completely new featureset, consider putting all of
the new code in a new file.

@item
Does a command need to be user-visible (``interactive'') or is it just
called by other commands?

@itemize
@item
If it's not going to be user-visible, you can just use the familiar
@code{(defun foo () ...)} syntax.

@item
If you want the command to be used interactively, you use DSWM's
@code{defcommand} syntax, as in the examples below.

@example
(defcommand test (foo bar)
   ((:string "How you're going to prompt for variable foo: ")
    (:number "How you want to prompt for variable bar: "))
   "This command is a test"
   (body...))

(defcommand test2 () ()
   "This is also a test"
   (body...))

(defcommand title (args) (interactive-args)
   "Doc string"
   (body...))
@end example

So basically, inside the first set of parentheses after the
function name, you specify what (if any) arguments will be passed to
the command. The second set of parentheses tells DSWM how to get
those arguments if they're not explicitly passed to the command. For
example,

@example
((:string "What do you want to do: "))
@end example

will read a string from the input the user provides. The quoted
text is the prompt the user will see. Of course, if you were to, say,
call the command test, as defined above, from another piece of code,
it wouldn't give the prompt as long as you fed it arguments.
@end itemize

@item
Note that all commands defined using the @code{defcommand} syntax are
available both to be called with @kbd{PREF ;} and from within other lisp
programs, as though they had been defun-ned (which, in fact, they
have).

@item
Any code that depends on external libraries or programs that some
users might not have installed should be placed in the @file{contrib/}
directory.

@item
Don't be afraid to submit your patches to the DSWM mailing list!
It may not immediately make it into the official git repository, but
individual users might find it useful and apply it to their own setup,
or might be willing to offer suggestions on how to improve the code.

@item
Remember:  DSWM is designed to run on both clisp and on SBCL. If
you must use code specific to one or the other, at the very least warn
people that it only works with one lisp implementation. Better yet,
figure out how to do it in the other distribution and write a
statement like this:

@example
#+clisp
(your-clisp-code)
#+sbcl
(your-sbcl-code)
@end example

#to wrap the code for each lisp. Of course, the best option is to
find a way to use the same code for clisp and SBCL.
@end enumerate

@node Using git with DSWM, Sending Patches, General Advice, Hacking
@section Hacking:  Using git with DSWM

For quite a while now, DSWM has been using the git version control
system for development. If you're one using one of the official
releases or still using the now-obsolete CVS version, you can get the
bleeding-edge source code from the official git repository with
a single command:

@example
$ git clone git://git.savannah.nongnu.org/dswm.git
@end example

After this, you'll have a complete git repository, along with the
complete revision history since the switch. Feel free to play around;
git has some important features that actually make this safe!

Before we get to that stuff, though, you're going to want to tell git
about yourself so that your information is included in your commits
and patches. The very minimum you're going to want to do is:

@example
$ git config --global user.name "Anne N. O'Nymous"
$ git config --global user.email "anonymous@@foo.org"
@end example

Be sure to check out the manual for @command{git-config}--there are several
options you might want to set, such as enabling colorized output or
changing the editor and pager you use when making commits and viewing
logs.

For the sake of argument, let's say you want to make some major
changes to both @file{user.lisp} and @file{core.lisp}, add a file called
@file{DANGEROUS_EXPERIMENT_DO_NOT_USE_OR_@-ELSE.lisp}, and remove the manual
because you're too 1337 for such things. However, you don't want to
break your entire DSWM setup and start over. Thankfully, you don't
have to. Before you get started, issue this command from the dswm
directory:

@example
$ git checkout -b experimental
@end example

You should now find yourself in a new branch, called experimental. To
confirm this, type @command{git branch}; there should be
an asterisk next to the branch you're currently viewing. At any time,
you can type @command{git checkout master} to return to your master branch,
and at any time you can have as many branches of the project as you
like. If you want to create a new branch based not on the master
branch but on your experimental branch, for example, you'd type:

@example
$ git checkout -b new-experiment experimental
@end example

This will place you in a newly-created branch called ``new-experiment''
which should be identical to your experimental branch as of the last
commit (more on that soon). If you're actually typing out the
directions, switch back to your old experimental branch like so:

@example
$ git checkout experimental
@end example

Anyway, now that you have a new branch, create that new file with the
long name, which I'll just call @file{danger.lisp} for brevity. Make whatever
changes you want to it, and when you're done, tell git about your new
file.

@example
$ git add dangerous.lisp
@end example

Now, let's pretend you're done making changes. Tell git you're done
for now:

@example
$ git commit -a
@end example

This will open up a prompt in your editor of choice for you to
describe your changes. Try to keep the first line short, and then add
more explanation underneath (for an example, run the command @command{git log}
and take a look at some of the longer commit explanations). Save that
file and then do this:

@example
$ git checkout master
$ ls
@end example

Then look for your new file. It's not there! That's because you've
done all of your work in another branch, which git is currently hiding
from you so that you can ``check out'' the branch called ``master.'' All
is as it should be--your master repository is still safe.

@example
$ git checkout experimental
@end example

Now, delete @file{manual.lisp} and @file{dswm.texi}. That's right. Wipe them off
the face of the Earth, or at least off the hard drive of your
computer. When you're done, you don't have to tell git you've deleted
them; it'll figure it out on its own (though things may not compile
properly unless you edit @file{Makefile.in} and @file{dswm.asd}. Anyway, go ahead
and edit @file{core.lisp} and @file{user.lisp}. Really break 'em. Run free! When
you're done, do another commit, as above, and give it a stupid title
like ``lolz i b0rked stUmpwm guys wTF!?!?!!111!'' Now try to compile.
Just try. It won't work. If it does, you're some kind of savant or
something. Keep up the good work. If you've actually managed to break
DSWM like you were supposed to, never fear! You have two options at
this point.

One is to go back to the master branch (with another git checkout) and
just delete your experimental branch, like so:

@example
$ git branch -D
@end example

The ``@code{-D}'' means to force a delete, even if the changes you've made
aren't available elsewhere. A ``@code{-d}'' means to delete the branch if and
only if you've merged the changes in elsewhere.

The other option is to create patches for each of your commits so far,
delete the branch, and then apply any working/wanted patches in a new
branch. Create your patches (after committing) like so:

@example
$ git format-patch -o patches origin
@end example

(Before doing that you can review your changes with @command{git log origin..})

You can also use the @command{format-patch} command to create a patch of working
code to send in to the mailing list.

A developer might ask you to try out something they're working on. To
fetch their master branch, you'd do this:

@example
$ git remote add -f -m master -t master foo git://bar.org/~foo/dswm
@end example

Here, ``foo'' is the shorthand name you'll use to refer to that
repository in the future. To checkout a local copy of that repository,
you'd then do

@example
$ git checkout --track -b foo-master foo/master
@end example

Later you could use @command{git pull foo} to update while looking at that
branch (and note that @command{git pull} with no arguments, in the master
branch, will update your DSWM from the official repository).

Finally, if you want to move your experimental changes into your
master branch, you'd checkout your master branch and run:

@example
$ git merge experimental
@end example

If there are file conflicts, @command{git diff} will show you where they are;
you have to fix them by hand. When you're done, do another

@example
$ git commit -a
@end example

to finalize the changes to your master branch. You can then delete
your experimental branch. Alternately, you can wait until your changes
(assuming you sent them in) make it into the official repository
before deleting your experimental branch.

@node Sending Patches,  , Using git with DSWM, Hacking
@section Sending Patches
When sending patches to the mailing list for inclusion in DSWM,
there are a few guidelines that will make everything go smoother.

@itemize
@item
Make sure it applies clean to the main git repository

@item
Ensure that you aren't introducing tabs, extra blank lines, or whitespace at the end of lines.

@item
Ensure your patch doesn't contain irrelevant indenting or reformatting changes.

@item
Try to make your patch address a single issue. If your patch changes
two unrelated issues, break them into two seperate patches that can
stand on their own.

@item
Don't send intermediate patches. When you're working on a feature you
might make several commits to your local repository as you refine it
and work out the bugs. When it's polished and ready to ship, send it
as one patch! Sometimes it makes sense to send it as multiple patches
if each patch contains a discrete feature or bug fix that can stand on
its own. If one of your patches changes code that was added or
modified in an earlier patch, consider merging them together and
sending them as one.

@end itemize

@node Command and Function Index, Variable Index, Hacking, Top
@unnumbered Command and Function Index
@printindex fn

@node Variable Index,  , Command and Function Index, Top
@unnumbered Variable Index
@printindex vr

@bye
